/*
	Manager responsible for loading and maintaining the life cycle of all modules.

	The system's ModuleManager starts with a built-in ModulePartLoader, which
	loads native libraries built from code generated by the Coral Compiler.

	Loaded modules may install additional ModulePart loaders in order to enable
	modules based on other kinds of artifacts (e.g. script files).
 */
interface ModuleManager
{
	// List of all loaded modules.
	readonly attribute Module[] modules;

	// List of installed ModulePart loaders.
	readonly attribute ModulePartLoader[] loaders;

	/*
		If true (default), the built-in ModulePartLoader will protect application by checking
		whether native modules are binary-compatible with the Coral core and installed types.
		When false, applications are able to load incompatible modules, but will subject to
		sudden crashes due to ABI incompatibilities.
	 */
	attribute bool binaryCompatibilityChecks;

	/*
		Finds an already loaded module given its fully-qualified \c moduleName.
		If the module was not previously loaded, returns null.
	 */
	Module findModule( in string moduleName );

	/*
		Installs a new ModulePartLoader.
		\throw co::IllegalArgumentException if the loader is invalid.
	 */
	void installLoader( in ModulePartLoader loader );

	/*
		Uninstalls a currently installed ModulePartLoader.
		\throw co::IllegalArgumentException if the loader is not currently installed.
	 */
	void uninstallLoader( in ModulePartLoader loader );

	/*
		Returns whether \c moduleName identifies a potentially loadable module
		(i.e. whether one of the installed loaders identified a loadable artifact
		within the module's directory).

		Please notice that a positive result <b>does not</b> mean that load() will
		succeed for the given module.
	 */
	bool isLoadable( in string moduleName );

	/*
		Loads or retrieves the module with the given fully-qualified \c moduleName.

		If the specified module is not loaded and none of the installed loaders is
		able to load it, a co::ModuleLoadException will be raised.

		When a module is loaded, it is brought up to date with the current state
		of the system. If an exception is thrown by the module or an error is
		detected during this process, the module will be unloaded and marked as
		aborted (ModuleState_Aborted), and a co::ModuleLoadException will be raised.

		Attempts to load a module that was previously marked as aborted will
		immediately raise a co::ModuleLoadException.

		This method can only be used after the system is set up, and only if it
		is not being torn down; otherwise, a co::LifeCycleException will be raised.
	 */
	Module load( in string moduleName ) raises ModuleLoadException, LifeCycleException;
};
