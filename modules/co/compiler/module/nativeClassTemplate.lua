local function writeDefaultReturn( writer, t, returnType )
	if not returnType then return end

	local result = nil
	local kind = returnType.kind
	if kind == 'TK_INTERFACE' then
		result = "NULL"
	elseif kind == 'TK_STRUCT' or kind == 'TK_NATIVECLASS' then
		writer( "\tstatic ", returnType.cppName, " dummy;\n" )
	elseif kind == 'TK_STRING' then
		writer( "\tstatic std::string dummy;\n" )
	elseif kind == 'TK_ANY' then
		writer( "\tstatic co::Any dummy;\n" )
	else
		result = t.formatInput( returnType ) .. "()"
	end
	writer( "\treturn ", result and result or "dummy", ";\n" )
end

local function writeMethodTemplate( writer, t, methodName, returnType, parameters )
	writer( [[

]], t.formatInput( returnType ), " ", t.name, "::", methodName, "( ", t.cppName, "& instance" )
	if parameters and #parameters > 0 then
		for i, p in ipairs( parameters ) do
			local paramType = ( p.isOut and t.formatOutput or t.formatInput )( p.type )
			writer( paramType, " ", p.name, ( i < #parameters and ', ' or '' ) )
		end
	end
	writer( [[ )
{
	// TODO: implement this function.
]] )
	writeDefaultReturn( writer, t, returnType )
	writer( [[
}
]] )
end

local function template( writer, c, t )
	writer( [[
/*
 * Native class adapter template for ']], t.fullName, [['.
 * WARNING: remember to copy this file to your project dir before you begin to change it.
 * Generated by the Coral Compiler v]], co.version, [[ on ]], t.currentDateTime(), [[.
 */

#include "]], t.name, [[_Adapter.h"

]] )

	c.utils.openNamespaces( writer, c.moduleName )

	-- Fields
	for i, field in ipairs( t.fields ) do
		writeMethodTemplate( writer, t, t.formatAccessor( "get", field.name ), field.type )
		if not field.isReadOnly then
			writeMethodTemplate( writer, t, t.formatAccessor( "set", field.name ), nil, { field } )
		end
	end

	-- Methods
	for i, method in ipairs( t.methods ) do
		writeMethodTemplate( writer, t, method.name, method.returnType, method.parameters )
	end

	writer( "\n" )

	c.utils.closeNamespaces( writer, c.moduleName )
end

return template
