local function writeMethod( writer, t, methodName, parameters, returnType, code )
	writer( [[

	]], t.formatResult( returnType ), [[ ]], methodName, "(" )
	if parameters and #parameters > 0 then
		writer( " " )
		for i, p in ipairs( parameters ) do
			local paramType = ( p.isOut and t.formatOutput or t.formatInput )( p.type )
			writer( paramType, " ", p.name, ( i < #parameters and ', ' or '' ) )
		end
		writer( " " )
	end
	if not code then
		code = "// TODO: implement this method."
	end
	writer( ")\n\t{\n\t\t", code, "\n\t}\n" )
end

local function formatGetterCode( fieldName, fieldType )
	return "return _" .. fieldName .. ( fieldType.kind == 'TK_INTERFACE' and ".get();" or ";" )
end

local function formatSetterCode( fieldName, fieldType )
	if fieldType.kind == 'TK_ARRAY' then
		return "co::assign( " .. fieldName .. ", _" .. fieldName .. " );"
	else
		return "_" .. fieldName .. " = " .. fieldName .. ";"
	end
end

local function extractInterfaces( facets )
	local implemented = {}
	local interfaces = {}
	for _, facet in ipairs( facets ) do
		local type = facet.type
		local superTypes = type.superTypes
		for i = #superTypes - 1, 1, -1 do
			local itf = superTypes[i]
			if not implemented[itf] then
				interfaces[#interfaces + 1] = itf
			end
		end
		if not implemented[type] then
			interfaces[#interfaces + 1] = type
		end
	end
	return interfaces
end

local function template( writer, c, t )
	writer( [[
/*
 * Component implementation template for ']], t.fullName, [['.
 * WARNING: remember to copy this file to your project dir before you begin to change it.
 * Generated by the Coral Compiler v]], co.version, [[ on ]], t.currentDateTime(), [[.p
 */

#include "]], t.name, [[_Base.h"
]] )

	for _, facet in ipairs( t.facets ) do
		for fullName, type in pairs( facet.type.typesNeededInReflector ) do
			writer( "#include <", type.headerName, ">\n" )
		end
	end

	writer( "\n" )

	c.utils.openNamespaces( writer, c.moduleName )

	writer( [[

class ]], t.name, [[ : public ]], t.name, [[_Base
{
public:
	]], t.name, [[()
	{
		// empty constructor
	}

	virtual ~]], t.name, [[()
	{
		// empty destructor
	}
]] )

	local interfaces = extractInterfaces( t.facets )
	for _, itf in ipairs( interfaces ) do
		writer( [[

	// ------ ]], itf.fullName, [[ Methods ------ //
]] )
		-- Field Accessors
		for _, field in ipairs( itf.fields ) do
			writeMethod( writer, t, t.formatAccessor( "get", field.name ), nil,
				field.type, formatGetterCode( field.name, field.type ) )
			if not field.isReadOnly then
				writeMethod( writer, t, t.formatAccessor( "set", field.name ), { field },
					nil, formatSetterCode( field.name, field.type ) )
			end
		end

		-- Methods
		for _, method in ipairs( itf.methods ) do
			local code
			if method.returnType then
				code = "static " .. t.formatField( method.returnType ) .. " dummy;\n\t\treturn dummy;"
			end
			writeMethod( writer, t, method.name, method.parameters, method.returnType, code )
		end
	end

	if #t.receptacles > 0 then
		writer( "\nprotected:" )

		for _, receptacle in ipairs( t.receptacles ) do
			writer( [[

	// ------ Receptacle ']], receptacle.name, [[' (]], receptacle.type.fullName, [[) ------ //
]] )
			local fieldName = receptacle.name .. "Service"
			writeMethod( writer, t, t.formatAccessor( "get", receptacle.name, "Service" ), nil,
				receptacle.type, formatGetterCode( fieldName, receptacle.type ) )
			writeMethod( writer, t, t.formatAccessor( "set", receptacle.name, "Service" ), { receptacle },
				nil, formatSetterCode( fieldName, receptacle.type ) )
		end
	end

	writer( [[

private:
	// member variables
]] )

	-- Declare Field Variables
	for _, itf in ipairs( interfaces ) do
		for _, field in ipairs( itf.fields ) do
			writer( "\t", t.formatField( field.type ), " _" .. field.name .. ";\n" )
		end
	end

	-- Declare Receptacle Variables
	for _, receptacle in ipairs( t.receptacles ) do
		writer( "\t", t.formatField( receptacle.type ), " _" .. receptacle.name .. "Service;\n" )
	end

	writer( [[
};

CORAL_EXPORT_COMPONENT( ]], t.name, [[, ]], t.name, [[ );

]] )

	c.utils.closeNamespaces( writer, c.moduleName )
end

return template
