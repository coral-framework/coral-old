local function writeDefaultReturn( writer, t, returnType )
	if not returnType then return end

	local result = nil
	local kind = returnType.kind
	if kind == 'TK_INTERFACE' then
		result = "NULL"
	elseif kind == 'TK_STRUCT' or kind == 'TK_NATIVECLASS' then
		writer( "\t\tstatic ", returnType.cppName, " dummy;\n" )
	elseif kind == 'TK_STRING' then
		writer( "\t\tstatic std::string dummy;\n" )
	elseif kind == 'TK_ANY' then
		writer( "\t\tstatic co::Any dummy;\n" )
	else
		result = t.formatInput( returnType ) .. "()"
	end
	writer( "\t\treturn ", result and result or "dummy", ";\n" )
end

local function writeMethodTemplate( writer, t, methodName, returnType, parameters )
	writer( [[

	]], t.formatInput( returnType ), [[ ]], methodName, "(" )
	if parameters and #parameters > 0 then
		writer( " " )
		for i, p in ipairs( parameters ) do
			local paramType = ( p.isOut and t.formatOutput or t.formatInput )( p.type )
			writer( paramType, " ", p.name, ( i < #parameters and ', ' or '' ) )
		end
		writer( " " )
	end
	writer( [[)
	{
		// TODO: implement this method.
]] )
	writeDefaultReturn( writer, t, returnType )
	writer( [[
	}
]] )
end

local function template( writer, c, t )
	writer( [[
/*
 * Component implementation template for ']], t.fullName, [['.
 * WARNING: remember to copy this file to your project dir before you begin to change it.
 * Generated by the Coral Compiler v]], co.version, [[ on ]], t.currentDateTime(), [[.
 */

#include "]], t.name, [[_Base.h"
]] )

	for i, facet in ipairs( t.facets ) do
		for fullName, type in pairs( facet.type.typesNeededInReflector ) do
			writer( "#include <", type.headerName, ">\n" )
		end
	end

	writer( "\n" )

	c.utils.openNamespaces( writer, c.moduleName )

	writer( [[

class ]], t.name, [[ : public ]], t.name, [[_Base
{
public:
	]], t.name, [[()
	{
		// empty constructor
	}

	virtual ~]], t.name, [[()
	{
		// empty destructor
	}
]] )

	for i, facet in ipairs( t.facets ) do
		writer( [[

	// ------ ]], facet.type.fullName, [[ Methods ------ //
]] )
		local itf = facet.type

		-- Field Accessors
		for i, field in ipairs( itf.fields ) do
			writeMethodTemplate( writer, t, t.formatAccessor( "get", field.name ), field.type )
			if not field.isReadOnly then
				writeMethodTemplate( writer, t, t.formatAccessor( "set", field.name ), nil, { field } )
			end
		end

		-- Methods
		for i, method in ipairs( itf.methods ) do
			writeMethodTemplate( writer, t, method.name, method.returnType, method.parameters )
		end
	end

	if #t.receptacles > 0 then
		writer( "\nprotected:" )

		for i, receptacle in ipairs( t.receptacles ) do
			writer( [[

	// ------ Receptacle ']], receptacle.name, [[' (]], receptacle.type.fullName, [[) ------ //
]] )
			writeMethodTemplate( writer, t, t.formatAccessor( "get", receptacle.name, "Service" ), receptacle.type )
			writeMethodTemplate( writer, t, t.formatAccessor( "set", receptacle.name, "Service" ), nil, { receptacle } )
		end
	end

	writer( [[

private:
	// member variables go here
};

CORAL_EXPORT_COMPONENT( ]], t.name, [[, ]], t.name, [[ );

]] )

	c.utils.closeNamespaces( writer, c.moduleName )
end

return template
