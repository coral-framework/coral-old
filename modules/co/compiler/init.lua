-------------------------------------------------------------------------------
-- Coral CSL Compiler Module
-------------------------------------------------------------------------------

local lfs = require "lfs"
local path = require "co.compiler.path"
local dependencies = require "co.compiler.dependencies"
local TypeWrapper = require "co.compiler.TypeWrapper"

local mapping = require "co.compiler.mapping"

local componentBaseHeader = require "co.compiler.module.componentBaseHeader"
local componentBaseSource = require "co.compiler.module.componentBaseSource"
local nativeClassAdapter = require "co.compiler.module.nativeClassAdapter"
local reflector = require "co.compiler.module.reflector"

local moduleBootstrap = require "co.compiler.module.bootstrap"
local moduleInstallerHeader = require "co.compiler.module.installerHeader"
local moduleInstallerSource = require "co.compiler.module.installerSource"
local moduleDefaultPart = require "co.compiler.module.defaultPart"

-- Compiler Class
local Compiler = {
	------ Default Field Values --
	outDir = "./generated",		-- output dir for generated files
	numGeneratedMappings = 0,	-- counts the number of mappings generated
	log = function( ... ) end,	-- function called to print misc. info (stats, etc.)

	------ Easy access to re-usable modules/templates ------
	utils = require "co.compiler.utils",
	header = require "co.compiler.header",
	revisionCheck = require "co.compiler.module.revisionCheck",
}

Compiler.__index = Compiler

-- Creates a new Compiler instance.
function Compiler:new()
	local self = setmetatable( {}, Compiler )

	-- array of module types
	self.types = {}

	-- map of direct type dependencies for the module
	-- includes all module types and all explicitly-specified dependencies
	-- these are the types for which we should generate mappings
	self.dependencies = {} -- map[type] = distance

	return self
end

-- Add a type whose mapping should be generated by the next call to generateMappings().
-- It will also be considered a module dependency, if we're generating a module.
function Compiler:addType( typeName )
	local t = TypeWrapper:wrap( co.getType( typeName ) )
	self.dependencies[t] = 1
end

-- Creates a dir hierarchy, opens a file and writes the given template, passing it 'data'.
local function expand( dir, filename, template, ... )
	path.makePath( dir )
	local f = io.open( dir .. '/' .. filename, "w" )
	template( function( ... ) f:write( ... ) end, ... )
	f:close()
end

local function isBuiltInType( t )
	local name = t.fullName
	return name == 'co.Interface' or name == 'co.TypeKind'
end

-- Runs the compiler to generate mappings. Use this when you don't need to generate a module.
function Compiler:generateMappings()
	assert( self.numGeneratedMappings == 0, "this compiler instance has already been used" )

	if not self.mappingsDir then
		self.mappingsDir = self.outDir
	end

	-- generate mappings for the types in 'types' and all their dependencies
	for t, dist in dependencies( self.dependencies ) do
		-- we may find additional direct module dependencies
		if dist <= 1 then self.dependencies[t] = dist end
		-- only generate mappings for non-component, non-built-in types
		if t.kind ~= 'TK_COMPONENT' and not isBuiltInType( t ) then
			local dir = self.mappingsDir .. '/' .. t.namespace.fullName:gsub( '%.', '/' )
			expand( dir, t.name .. '.h', mapping, self, t )
			self.numGeneratedMappings = self.numGeneratedMappings + 1
		end
	end

	self.log( "Created " .. self.numGeneratedMappings .. " mappings." )
end

-- Runs the compiler to generate a module. Also generates the necessary mappings.
function Compiler:generateModule( moduleName )
	assert( self.moduleName == nil, "this compiler instance has already been used" )

	self.moduleName = moduleName
	self.moduleNS = self.utils.toCppName( moduleName )
	self.log( "Processing module '" .. self.moduleName .. "'..." )

	self:loadModuleTypes()
	self.log( "Found " .. #self.types .. " module types." )

	-- add types that may not come as explicit dependencies, but are required by generated module code
	self:addType( "co.System" )
	self:addType( "co.Namespace" )
	self:addType( "co.Reflector" )
	self:addType( "co.ModulePart" )
	--  all type classes are implicit dependencies
	self:addType( "co.EnumType" )
	self:addType( "co.ArrayType" )
	self:addType( "co.StructType" )
	self:addType( "co.ExceptionType" )
	self:addType( "co.InterfaceType" )
	self:addType( "co.ComponentType" )
	self:addType( "co.NativeClassType" )

	-- generateMappings() also adds entries to self.dependencies
	self:generateMappings()

	self.log( "Generating module code..." )

	-- Generate per-type files
	for i, t in ipairs( self.types ) do
		if t.kind == 'TK_NATIVECLASS' then
			expand( self.outDir, t.name .. "_Adapter.h", nativeClassAdapter, self, t )
		elseif t.kind == 'TK_COMPONENT' then
			expand( self.outDir, t.name .. "_Base.h", componentBaseHeader, self, t )
			expand( self.outDir, t.name .. "_Base.cpp", componentBaseSource, self, t )
		end
		expand( self.outDir, t.name .. "_Reflector.cpp", reflector, self, t )
	end

	-- Generate per-module files
	expand( self.outDir, "__Bootstrap.cpp", moduleBootstrap, self )
	expand( self.outDir, "ModuleInstaller.h", moduleInstallerHeader, self )
	expand( self.outDir, "ModuleInstaller.cpp", moduleInstallerSource, self )
	if not self:hasCustomModulePart() then
		expand( self.outDir, "__ModulePart.cpp", moduleDefaultPart, self )
	end

	self.log( "Done." )
end

-- Loads all module types by locating CSL files in the module's namespace
-- (which may be scattered in several dirs in the Coral path).
function Compiler:loadModuleTypes()
	assert( #self.types == 0 )
	local moduleDirPath = self.moduleName:gsub( '%.', '/' )
	for i, repositoryDir in pairs( co.getPaths() ) do
		local moduleDir = repositoryDir .. '/' .. moduleDirPath
		if path.isDir( moduleDir ) then
			for filename in lfs.dir( moduleDir ) do
				local typeName = filename:match( "(.+)%.csl$" )
				if typeName then
					local moduleType = TypeWrapper:wrap( co.getType( self.moduleName .. '.' .. typeName ) )
					self.types[#self.types + 1] = moduleType
					self.dependencies[moduleType] = 0
				end
			end
		end
	end
end

-- Returns whether the module has a valid custom co.ModulePart.
function Compiler:hasCustomModulePart()
	local localModuleName = self.moduleName:match( '.-([^%.]+)$' )
	local t = co.system.types:findType( self.moduleName .. '.' .. localModuleName )
	local modulePartItf = co.getType( 'co.ModulePart' )
	if t and t.kind == 'TK_COMPONENT' then
		for i, itf in ipairs( t.providedInterfaces ) do
			if itf.type:isSubTypeOf( modulePartItf ) then
				if itf.name == 'part' then
					return true
				end
				error( "Module '" .. self.moduleName .. "' contains a component named '" ..
					self.moduleName .. "', but its co.ModulePart interface is not named 'part'."  )
			end
		end
		error( "Module '" .. self.moduleName .. "' contains a component named '" ..
			self.moduleName .. "', but it does not provide the co.ModulePart interface."  )
	end
	return false
end

return Compiler
