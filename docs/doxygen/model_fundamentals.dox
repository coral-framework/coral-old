/*!

\page model_fundamentals Fundamentos

Esta página resume os principais conceitos do Coral, provendo uma visão geral de sua arquitetura.

Para ter uma visão mais profunda e completa sobre um determinado assunto, veja as demais páginas no índice \ref model, ou clique nos links ao longo desta página.


\section sec_csl Linguagem de Especificação

A fim de permitir que diferentes linguagens de programação interoperem em um sistema de componentes, é necessário estabelecer um protocolo comum para a representação de dados e a invocação de operações.

Uma maneira de garantir isto é utilizando uma IDL (<em>Interface Definition Language</em>), e mapeamentos da IDL para as linguagens de programação desejadas. Com o auxílio de um compilador IDL, é possível gerar código automático que faz a conversão entre o protocolo específico de uma linguagem de programação e o protocolo comum.

O Coral define a linguagem <em>\ref csl</em>, que se assemelha a uma IDL simples, mas também serve para especificar componentes e "classes nativas" (um conceito próprio do Coral). Como o Coral baseia-se no C++, que não é uma linguagem reflexiva, a infra-estrutura da linguagem CSL também é usada para adicionar suporte a reflexão e introspecção de tipos.


\section sec_types Tipos

No Coral, tipos como enums, structs, interfaces e componentes são definidos em arquivos CSL, seguindo o padrão de nomenclatura &ldquo;<em><tt>NomeDoTipo.csl</tt></em>&rdquo;. Cada arquivo CSL contém a definição de <b>um único</b> tipo, cujo nome local deve ser igual ao nome do arquivo desconsiderando-se a extensão <tt>".csl"</tt>.

Os arquivos CSL podem ser organizados hierarquicamente, em diretórios. Por exemplo:

\verbatim
(raiz)
  |
  |- drink/
  |    |- IDrink.csl        - Interface IDrink
  |    |- IJuice.csl        - Interface IJuice, que herda de IDrink
  |    |- ILiquor.csl       - Interface ILiquor, que herda de IDrink
  |    +- liquor/
  |         |- IVodka.csl   - Interface IVodka, que herda de ILiquor
  |         +- IWhisky.csl  - Interface IWhisky, que herda de ILiquor
  |
  |- tasty/
  |    |- Absolut.csl       - Componente Absolut, que implementa IVodka
  |    +- Chivas.csl        - Componente Chivas, que implementa IWhisky
  |
  +- bargain/
       +- Smirnoff.csl      - Componente Smirnoff, que implementa IVodka
\endverbatim

Neste exemplo, a pasta <tt>(raiz)</tt> define um <b>repositório de tipos</b>. As subpastas <tt>drink</tt>, <tt>liquor</tt>, <tt>tasty</tt> e <tt>bargain</tt> definem <em>namespaces</em>, e finalmente os arquivos <tt>.csl</tt> definem tipos (no exemplo, interfaces e componentes).

O nome completo de um tipo inclui os namespaces aos quais ele pertence, desde a raiz do repositório, separados por ponto. Por exemplo, o nome completo da interface <tt>IVodka</tt> seria <tt>drink.liquor.IVodka</tt>, enquanto que o do componente <tt>Absolut</tt> seria <tt>tasty.Absolut</tt>.

A localização de tipos é feita através da variável <tt>CORAL_PATH</tt>, cujo comportamento é semelhante ao <em>classpath</em> do Java. Se a variável <tt>CORAL_PATH</tt> indicar mais de uma pasta raiz, o Coral fará as buscas por tipos em múltiplos repositórios &mdash; dando preferência ao repositório que aparecer primeiro na lista, em caso de conflitos.


\section sec_typeinfo Introspecção de Tipos

O Coral oferece introspecção completa para os tipos que compõem o sistema de componentes &mdash; o que inclui todos os tipos declarados em arquivos <tt>.csl</tt> que estejam dentro de um repositório de tipos.

A introspecção de um tipo é feita em C++ com o auxílio de um objeto do tipo <tt>Type</tt>. Todo tipo possui um <tt>Type</tt>, e todo <tt>Type</tt> possui identidade de referência. Ou seja, objetos do mesmo tipo compartilham a mesma instância de <tt>Type</tt>, e é possível comparar se dois objetos são exatamente do mesmo tipo verificando se eles têm o mesmo ponteiro para <tt>Type</tt>.

Além do <tt>Type</tt>, cada tipo do Coral é identificado por um nome (vide a seção anterior) e um UUID (<em>universally unique identifier</em>) de 128 bits. Em C++, é possível obter o nome ou o UUID de qualquer tipo conhecido, em tempo de compilação, através de dois operadores, como ilustrado abaixo:
\code
#include <drink/liquor/IVodka.h>

using drink::liquor::IVodka;

std::cout << co::nameOf<IVodka>() << std::endl
          << co::uuidOf<IVodka>() << std::endl;
\endcode

Como resultado, o exemplo acima imprimiria algo parecido com:
\verbatim
drink.liquor.IVodka
05692041-B27C-5384-DA2D3741F6EC8DF4
\endverbatim

Existem duas abordagens básicas para se obter o <tt>Type</tt> de um tipo. A primeira é baseada numa consulta pelo nome completo do tipo, e pode ser usada em qualquer situação. Por exemplo:
\code
// Type of interface 'drink.IJuice'
co::InterfaceType* t = co::TypeManager::getType<co::InterfaceType>( "drink.IJuice" );
\endcode

A segunda abordagem é mais simples, mas só é possível se o tipo for conhecido em tempo de compilação:
\code
#include <drink/IJuice.h>

co::InterfaceType* t = co::typeOf<drink::IJuice>();
\endcode

Internamente o operador <tt>co::typeOf<T>()</tt> faz uma busca baseada no UUID do tipo, o que geralmente é mais eficiente do que uma busca pelo nome. A operação funciona de forma semelhante ao código abaixo:
\code
template<typename T>
co::Type* typeOf()
{
    return co::TypeManager::findTypeByUuid( co::uuidOf<T>() );
}
\endcode


\section sec_typemanager Gerência de Tipos

A classe <tt>TypeManager</tt> é responsável por manter, em tempo de execução, um registro de todos os tipos conhecidos pela aplicação até o momento. Normalmente, um tipo é adicionado ao registro quando é usado pela primeira vez. Na prática, isto pode ocorrer em função dos seguintes eventos:
- <b>Quando um módulo é carregado</b>, todos os tipos utilizados pelo módulo, direta ou indiretamente, são verificados e registrados.
- <b>Quando o método <tt>TypeManager::get( <em>fullName</em> )</tt> é chamado</b>, se o nome especificado for de um tipo desconhecido, o tipo será automaticamente carregado e registrado. O arquivo <tt>.csl</tt> do tipo deverá estar em algum repositório listado no <tt>CORAL_PATH</tt>; caso contrário, o método lançará uma exceção.
- <b>Quando um novo tipo é definido dinamicamente</b> através do método <tt>co::Namespace::defineType()</tt>.

Com o auxílio do <tt>TypeManager</tt> e dos objetos <tt>Type</tt> é possível listar os métodos e atributos de qualquer tipo, navegar na hierarquia das interfaces conhecidas, e carregar todos os tipos presentes nos repositórios listados no <tt>CORAL_PATH</tt>.

Uma grande vantagem do modelo de repositório e registro de tipos do Coral é que a introspecção de tipos pode ser feita de forma muito eficiente, sem que nenhuma biblioteca dinâmica seja carregada. A biblioteca onde um tipo está implementado só precisa ser carregada caso o tipo seja instanciado, ou caso seja requerido o uso de reflexão para o tipo.


\section sec_reflection Reflexão

O suporte a programação reflexiva no Coral é o alicerce para inúmeros serviços do sistema de componentes.
O sistema de reflexão, oferecido como uma extensão do sistema de tipos, permite a <b>manipulação</b> de tipos e instâncias.

Enquanto que a introspecção de tipos é feita através de objetos do tipo <tt>Type</tt>, os serviços de reflexão são oferecidos por objetos do tipo <tt>Reflector</tt>. Alguns exemplos de operações oferecidas pelos <tt>Reflector</tt>'s são:
- Instanciação de um tipo.
- Obtenção e atribuição de valores para atributos.
- Chamadas dinâmicas de métodos de interfaces.
- Criação de <em>proxies</em> dinâmicos para interfaces.

Diferente do sistema de tipos, que precisa apenas de arquivos <tt>.csl</tt> para funcionar, o sistema de reflexão requer que as <em>bibliotecas dinâmicas</em> onde os tipos foram implementados estejam carregadas.
Por razões de desempenho, o carregamento de bibliotecas no Coral é feito de forma tardia (<em>lazy</em>). O principal evento que pode causar o carregamento de bibliotecas é justamente a obtenção de um <tt>Reflector</tt> para um tipo.


\section sec_modules Módulos

Um módulo é um <b>pacote de extensão</b> que adiciona novos tipos, recursos e funcionalidades às aplicações. Os módulos são as unidades de empacotamento e distribuição do Coral. Fisicamente, eles são diretórios; e podem conter bibliotecas dinâmicas, scripts Lua, arquivos CSL, imagens, etc.

Como descrito na seção \ref sec_types, todo diretório acessível através do <tt>CORAL_PATH</tt> define um <em>namespace</em>. Por sua vez, todo namespace é <em>potencialmente</em> um módulo. O que determina se um namespace é um módulo ou não é a existência de um <tt>ModuleLoader</tt> (uma interface) capaz de "carregar" um <tt>Module</tt> a partir do conteúdo do seu diretório.

Um mesmo módulo pode ser simultaneamente carregado por múltiplos <tt>ModuleLoader</tt>'s. Caso nenhum <tt>ModuleLoader</tt> seja capaz de carregar um módulo a partir de um certo diretório, o diretório é considerado apenas um namespace, e não um módulo. O Coral vem com um <tt>ModuleLoader</tt> padrão capaz de carregar módulos a partir de <em>biblioteca dinâmicas</em>. Neste caso, a biblioteca deve ter o mesmo nome do diretório do módulo.

*/