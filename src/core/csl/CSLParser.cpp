/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:45:30
 *
 *     -  From the grammar source file : /Users/tbastos/Projects/coral/src/core/csl/CSL.g
 *     -                            On : 2011-03-30 13:20:49
 *     -                for the parser : CSLParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "CSLParser.h"

	#undef pANTLR3_PARSER
	#include "Parser.h"
	#include <co/TypeKind.h>

/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCSLParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCSLParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCSLParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pCSLParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER				ctx->pParser  
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   CSLParserTokenNames[33+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "IMPORT",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "EXCEPTION_TOKEN",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "ENUM",
        (pANTLR3_UINT8) "OPEN_BLOCK",
        (pANTLR3_UINT8) "CLOSE_BLOCK",
        (pANTLR3_UINT8) "STRUCT",
        (pANTLR3_UINT8) "NATIVE",
        (pANTLR3_UINT8) "CLASS",
        (pANTLR3_UINT8) "OPEN_PAREN",
        (pANTLR3_UINT8) "CPP_TAG",
        (pANTLR3_UINT8) "CLOSE_PAREN",
        (pANTLR3_UINT8) "INTERFACE",
        (pANTLR3_UINT8) "COMPONENT",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "CPP_SCOPE",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "READONLY",
        (pANTLR3_UINT8) "RAISES",
        (pANTLR3_UINT8) "CPP_BLOCK",
        (pANTLR3_UINT8) "EXTENDS",
        (pANTLR3_UINT8) "TOK_VOID",
        (pANTLR3_UINT8) "BASIC_TYPE",
        (pANTLR3_UINT8) "OPEN_BRACE",
        (pANTLR3_UINT8) "CLOSE_BRACE",
        (pANTLR3_UINT8) "TOK_IN",
        (pANTLR3_UINT8) "TOK_OUT",
        (pANTLR3_UINT8) "TOK_INOUT",
        (pANTLR3_UINT8) "PROVIDES",
        (pANTLR3_UINT8) "RECEIVES",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "WS"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	csl_file    (pCSLParser ctx);
static void	specification    (pCSLParser ctx);
static void	import_clause    (pCSLParser ctx);
static void	exception_specification    (pCSLParser ctx);
static void	enum_specification    (pCSLParser ctx);
static void	struct_specification    (pCSLParser ctx);
static void	native_class_specification    (pCSLParser ctx);
static void	interface_specification    (pCSLParser ctx);
static void	component_specification    (pCSLParser ctx);
static CSLParser_identifier_return	identifier    (pCSLParser ctx);
static CSLParser_qualified_identifier_return	qualified_identifier    (pCSLParser ctx);
static CSLParser_cpp_type_return	cpp_type    (pCSLParser ctx);
static void	identifier_list    (pCSLParser ctx);
static void	record_member    (pCSLParser ctx);
static CSLParser_field_declaration_return	field_declaration    (pCSLParser ctx);
static void	class_member    (pCSLParser ctx);
static CSLParser_method_declaration_return	method_declaration    (pCSLParser ctx);
static void	parameter_declaration_list    (pCSLParser ctx);
static void	parameter_declaration    (pCSLParser ctx);
static void	exception_list    (pCSLParser ctx);
static void	interface_member    (pCSLParser ctx);
static void	inheritance_declaration    (pCSLParser ctx);
static CSLParser_component_member_return	component_member    (pCSLParser ctx);
static void	method_type_spec    (pCSLParser ctx);
static void	type_declaration    (pCSLParser ctx);
static void	pair_of_braces    (pCSLParser ctx);
static CSLParser_param_io_return	param_io    (pCSLParser ctx);
static bool	interface_role    (pCSLParser ctx);
static void	comment    (pCSLParser ctx);
static ANTLR3_BOOLEAN	synpred1_CSL    (pCSLParser ctx);
static void	CSLParserFree(pCSLParser ctx);
static void     CSLParserReset (pCSLParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/Users/tbastos/Projects/coral/src/core/csl/CSL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new CSLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCSLParser
CSLParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return CSLParserNewSSD(instream, NULL);
}

/** \brief Create a new CSLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCSLParser
CSLParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pCSLParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pCSLParser) ANTLR3_CALLOC(1, sizeof(CSLParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in CSLParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our CSLParser interface
     */
    ctx->csl_file	= csl_file;
    ctx->specification	= specification;
    ctx->import_clause	= import_clause;
    ctx->exception_specification	= exception_specification;
    ctx->enum_specification	= enum_specification;
    ctx->struct_specification	= struct_specification;
    ctx->native_class_specification	= native_class_specification;
    ctx->interface_specification	= interface_specification;
    ctx->component_specification	= component_specification;
    ctx->identifier	= identifier;
    ctx->qualified_identifier	= qualified_identifier;
    ctx->cpp_type	= cpp_type;
    ctx->identifier_list	= identifier_list;
    ctx->record_member	= record_member;
    ctx->field_declaration	= field_declaration;
    ctx->class_member	= class_member;
    ctx->method_declaration	= method_declaration;
    ctx->parameter_declaration_list	= parameter_declaration_list;
    ctx->parameter_declaration	= parameter_declaration;
    ctx->exception_list	= exception_list;
    ctx->interface_member	= interface_member;
    ctx->inheritance_declaration	= inheritance_declaration;
    ctx->component_member	= component_member;
    ctx->method_type_spec	= method_type_spec;
    ctx->type_declaration	= type_declaration;
    ctx->pair_of_braces	= pair_of_braces;
    ctx->param_io	= param_io;
    ctx->interface_role	= interface_role;
    ctx->comment	= comment;
    ctx->synpred1_CSL	= synpred1_CSL;
    ctx->free			= CSLParserFree;
    ctx->reset			= CSLParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = CSLParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
CSLParserReset (pCSLParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 CSLParserFree(pCSLParser ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return CSLParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_specification_in_csl_file70  */
static	ANTLR3_BITWORD FOLLOW_specification_in_csl_file70_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800061950) };
static  ANTLR3_BITSET_LIST FOLLOW_specification_in_csl_file70	= { FOLLOW_specification_in_csl_file70_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_csl_file73  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_csl_file73_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_csl_file73	= { FOLLOW_EOF_in_csl_file73_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_specification84  */
static	ANTLR3_BITWORD FOLLOW_comment_in_specification84_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_specification84	= { FOLLOW_comment_in_specification84_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_import_clause_in_specification89  */
static	ANTLR3_BITWORD FOLLOW_import_clause_in_specification89_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_import_clause_in_specification89	= { FOLLOW_import_clause_in_specification89_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_specification_in_specification94  */
static	ANTLR3_BITWORD FOLLOW_enum_specification_in_specification94_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_specification_in_specification94	= { FOLLOW_enum_specification_in_specification94_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exception_specification_in_specification99  */
static	ANTLR3_BITWORD FOLLOW_exception_specification_in_specification99_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exception_specification_in_specification99	= { FOLLOW_exception_specification_in_specification99_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_struct_specification_in_specification104  */
static	ANTLR3_BITWORD FOLLOW_struct_specification_in_specification104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_struct_specification_in_specification104	= { FOLLOW_struct_specification_in_specification104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_native_class_specification_in_specification109  */
static	ANTLR3_BITWORD FOLLOW_native_class_specification_in_specification109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_native_class_specification_in_specification109	= { FOLLOW_native_class_specification_in_specification109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interface_specification_in_specification114  */
static	ANTLR3_BITWORD FOLLOW_interface_specification_in_specification114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_interface_specification_in_specification114	= { FOLLOW_interface_specification_in_specification114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_component_specification_in_specification119  */
static	ANTLR3_BITWORD FOLLOW_component_specification_in_specification119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_component_specification_in_specification119	= { FOLLOW_component_specification_in_specification119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPORT_in_import_clause130  */
static	ANTLR3_BITWORD FOLLOW_IMPORT_in_import_clause130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPORT_in_import_clause130	= { FOLLOW_IMPORT_in_import_clause130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_identifier_in_import_clause134  */
static	ANTLR3_BITWORD FOLLOW_qualified_identifier_in_import_clause134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_identifier_in_import_clause134	= { FOLLOW_qualified_identifier_in_import_clause134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_import_clause136  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_import_clause136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_import_clause136	= { FOLLOW_SEMICOLON_in_import_clause136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXCEPTION_TOKEN_in_exception_specification151  */
static	ANTLR3_BITWORD FOLLOW_EXCEPTION_TOKEN_in_exception_specification151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_EXCEPTION_TOKEN_in_exception_specification151	= { FOLLOW_EXCEPTION_TOKEN_in_exception_specification151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_exception_specification155  */
static	ANTLR3_BITWORD FOLLOW_ID_in_exception_specification155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_exception_specification155	= { FOLLOW_ID_in_exception_specification155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_exception_specification157  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_exception_specification157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_exception_specification157	= { FOLLOW_SEMICOLON_in_exception_specification157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUM_in_enum_specification172  */
static	ANTLR3_BITWORD FOLLOW_ENUM_in_enum_specification172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUM_in_enum_specification172	= { FOLLOW_ENUM_in_enum_specification172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_enum_specification176  */
static	ANTLR3_BITWORD FOLLOW_ID_in_enum_specification176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_enum_specification176	= { FOLLOW_ID_in_enum_specification176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_BLOCK_in_enum_specification184  */
static	ANTLR3_BITWORD FOLLOW_OPEN_BLOCK_in_enum_specification184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000080) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_BLOCK_in_enum_specification184	= { FOLLOW_OPEN_BLOCK_in_enum_specification184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_list_in_enum_specification186  */
static	ANTLR3_BITWORD FOLLOW_identifier_list_in_enum_specification186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_list_in_enum_specification186	= { FOLLOW_identifier_list_in_enum_specification186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_BLOCK_in_enum_specification188  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_BLOCK_in_enum_specification188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_BLOCK_in_enum_specification188	= { FOLLOW_CLOSE_BLOCK_in_enum_specification188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_enum_specification190  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_enum_specification190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_enum_specification190	= { FOLLOW_SEMICOLON_in_enum_specification190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRUCT_in_struct_specification201  */
static	ANTLR3_BITWORD FOLLOW_STRUCT_in_struct_specification201_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_STRUCT_in_struct_specification201	= { FOLLOW_STRUCT_in_struct_specification201_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_struct_specification205  */
static	ANTLR3_BITWORD FOLLOW_ID_in_struct_specification205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_struct_specification205	= { FOLLOW_ID_in_struct_specification205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_BLOCK_in_struct_specification213  */
static	ANTLR3_BITWORD FOLLOW_OPEN_BLOCK_in_struct_specification213_bits[]	= { ANTLR3_UINT64_LIT(0x0000000808400480) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_BLOCK_in_struct_specification213	= { FOLLOW_OPEN_BLOCK_in_struct_specification213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_record_member_in_struct_specification215  */
static	ANTLR3_BITWORD FOLLOW_record_member_in_struct_specification215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000808400480) };
static  ANTLR3_BITSET_LIST FOLLOW_record_member_in_struct_specification215	= { FOLLOW_record_member_in_struct_specification215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_BLOCK_in_struct_specification218  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_BLOCK_in_struct_specification218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_BLOCK_in_struct_specification218	= { FOLLOW_CLOSE_BLOCK_in_struct_specification218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_struct_specification220  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_struct_specification220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_struct_specification220	= { FOLLOW_SEMICOLON_in_struct_specification220_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NATIVE_in_native_class_specification231  */
static	ANTLR3_BITWORD FOLLOW_NATIVE_in_native_class_specification231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_NATIVE_in_native_class_specification231	= { FOLLOW_NATIVE_in_native_class_specification231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLASS_in_native_class_specification235  */
static	ANTLR3_BITWORD FOLLOW_CLASS_in_native_class_specification235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_CLASS_in_native_class_specification235	= { FOLLOW_CLASS_in_native_class_specification235_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_native_class_specification237  */
static	ANTLR3_BITWORD FOLLOW_ID_in_native_class_specification237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_native_class_specification237	= { FOLLOW_ID_in_native_class_specification237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_PAREN_in_native_class_specification245  */
static	ANTLR3_BITWORD FOLLOW_OPEN_PAREN_in_native_class_specification245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_PAREN_in_native_class_specification245	= { FOLLOW_OPEN_PAREN_in_native_class_specification245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CPP_TAG_in_native_class_specification247  */
static	ANTLR3_BITWORD FOLLOW_CPP_TAG_in_native_class_specification247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_CPP_TAG_in_native_class_specification247	= { FOLLOW_CPP_TAG_in_native_class_specification247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cpp_type_in_native_class_specification249  */
static	ANTLR3_BITWORD FOLLOW_cpp_type_in_native_class_specification249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_cpp_type_in_native_class_specification249	= { FOLLOW_cpp_type_in_native_class_specification249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_PAREN_in_native_class_specification251  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_PAREN_in_native_class_specification251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_PAREN_in_native_class_specification251	= { FOLLOW_CLOSE_PAREN_in_native_class_specification251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_BLOCK_in_native_class_specification259  */
static	ANTLR3_BITWORD FOLLOW_OPEN_BLOCK_in_native_class_specification259_bits[]	= { ANTLR3_UINT64_LIT(0x000000080C400480) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_BLOCK_in_native_class_specification259	= { FOLLOW_OPEN_BLOCK_in_native_class_specification259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_class_member_in_native_class_specification261  */
static	ANTLR3_BITWORD FOLLOW_class_member_in_native_class_specification261_bits[]	= { ANTLR3_UINT64_LIT(0x000000080C400480) };
static  ANTLR3_BITSET_LIST FOLLOW_class_member_in_native_class_specification261	= { FOLLOW_class_member_in_native_class_specification261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_BLOCK_in_native_class_specification264  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_BLOCK_in_native_class_specification264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_BLOCK_in_native_class_specification264	= { FOLLOW_CLOSE_BLOCK_in_native_class_specification264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_native_class_specification266  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_native_class_specification266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_native_class_specification266	= { FOLLOW_SEMICOLON_in_native_class_specification266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTERFACE_in_interface_specification277  */
static	ANTLR3_BITWORD FOLLOW_INTERFACE_in_interface_specification277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_INTERFACE_in_interface_specification277	= { FOLLOW_INTERFACE_in_interface_specification277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_interface_specification281  */
static	ANTLR3_BITWORD FOLLOW_ID_in_interface_specification281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000200) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_interface_specification281	= { FOLLOW_ID_in_interface_specification281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inheritance_declaration_in_interface_specification289  */
static	ANTLR3_BITWORD FOLLOW_inheritance_declaration_in_interface_specification289_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_inheritance_declaration_in_interface_specification289	= { FOLLOW_inheritance_declaration_in_interface_specification289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_BLOCK_in_interface_specification292  */
static	ANTLR3_BITWORD FOLLOW_OPEN_BLOCK_in_interface_specification292_bits[]	= { ANTLR3_UINT64_LIT(0x000000080D400480) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_BLOCK_in_interface_specification292	= { FOLLOW_OPEN_BLOCK_in_interface_specification292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interface_member_in_interface_specification294  */
static	ANTLR3_BITWORD FOLLOW_interface_member_in_interface_specification294_bits[]	= { ANTLR3_UINT64_LIT(0x000000080D400480) };
static  ANTLR3_BITSET_LIST FOLLOW_interface_member_in_interface_specification294	= { FOLLOW_interface_member_in_interface_specification294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_BLOCK_in_interface_specification297  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_BLOCK_in_interface_specification297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_BLOCK_in_interface_specification297	= { FOLLOW_CLOSE_BLOCK_in_interface_specification297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_interface_specification299  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_interface_specification299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_interface_specification299	= { FOLLOW_SEMICOLON_in_interface_specification299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMPONENT_in_component_specification310  */
static	ANTLR3_BITWORD FOLLOW_COMPONENT_in_component_specification310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COMPONENT_in_component_specification310	= { FOLLOW_COMPONENT_in_component_specification310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_component_specification314  */
static	ANTLR3_BITWORD FOLLOW_ID_in_component_specification314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_component_specification314	= { FOLLOW_ID_in_component_specification314_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_BLOCK_in_component_specification322  */
static	ANTLR3_BITWORD FOLLOW_OPEN_BLOCK_in_component_specification322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000E00000400) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_BLOCK_in_component_specification322	= { FOLLOW_OPEN_BLOCK_in_component_specification322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_component_member_in_component_specification324  */
static	ANTLR3_BITWORD FOLLOW_component_member_in_component_specification324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000E00000400) };
static  ANTLR3_BITSET_LIST FOLLOW_component_member_in_component_specification324	= { FOLLOW_component_member_in_component_specification324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_BLOCK_in_component_specification327  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_BLOCK_in_component_specification327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_BLOCK_in_component_specification327	= { FOLLOW_CLOSE_BLOCK_in_component_specification327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_component_specification329  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_component_specification329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_component_specification329	= { FOLLOW_SEMICOLON_in_component_specification329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_identifier0  */
static	ANTLR3_BITWORD FOLLOW_set_in_identifier0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_identifier0	= { FOLLOW_set_in_identifier0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_qualified_identifier361  */
static	ANTLR3_BITWORD FOLLOW_ID_in_qualified_identifier361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_qualified_identifier361	= { FOLLOW_ID_in_qualified_identifier361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_qualified_identifier365  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_qualified_identifier365_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_qualified_identifier365	= { FOLLOW_DOT_in_qualified_identifier365_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_qualified_identifier367  */
static	ANTLR3_BITWORD FOLLOW_ID_in_qualified_identifier367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_qualified_identifier367	= { FOLLOW_ID_in_qualified_identifier367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_cpp_type381  */
static	ANTLR3_BITWORD FOLLOW_ID_in_cpp_type381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000108002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_cpp_type381	= { FOLLOW_ID_in_cpp_type381_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CPP_SCOPE_in_cpp_type385  */
static	ANTLR3_BITWORD FOLLOW_CPP_SCOPE_in_cpp_type385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_CPP_SCOPE_in_cpp_type385	= { FOLLOW_CPP_SCOPE_in_cpp_type385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_cpp_type387  */
static	ANTLR3_BITWORD FOLLOW_ID_in_cpp_type387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000108002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_cpp_type387	= { FOLLOW_ID_in_cpp_type387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CPP_TAG_in_cpp_type392  */
static	ANTLR3_BITWORD FOLLOW_CPP_TAG_in_cpp_type392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CPP_TAG_in_cpp_type392	= { FOLLOW_CPP_TAG_in_cpp_type392_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_identifier_list404  */
static	ANTLR3_BITWORD FOLLOW_comment_in_identifier_list404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000080) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_identifier_list404	= { FOLLOW_comment_in_identifier_list404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_identifier_list411  */
static	ANTLR3_BITWORD FOLLOW_ID_in_identifier_list411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800200002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_identifier_list411	= { FOLLOW_ID_in_identifier_list411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_identifier_list421  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_identifier_list421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_identifier_list421	= { FOLLOW_COMMA_in_identifier_list421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_identifier_list423  */
static	ANTLR3_BITWORD FOLLOW_comment_in_identifier_list423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000080) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_identifier_list423	= { FOLLOW_comment_in_identifier_list423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_identifier_list430  */
static	ANTLR3_BITWORD FOLLOW_ID_in_identifier_list430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800200002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_identifier_list430	= { FOLLOW_ID_in_identifier_list430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_identifier_list442  */
static	ANTLR3_BITWORD FOLLOW_comment_in_identifier_list442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_identifier_list442	= { FOLLOW_comment_in_identifier_list442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_record_member454  */
static	ANTLR3_BITWORD FOLLOW_comment_in_record_member454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_record_member454	= { FOLLOW_comment_in_record_member454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_field_declaration_in_record_member459  */
static	ANTLR3_BITWORD FOLLOW_field_declaration_in_record_member459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_field_declaration_in_record_member459	= { FOLLOW_field_declaration_in_record_member459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_READONLY_in_field_declaration470  */
static	ANTLR3_BITWORD FOLLOW_READONLY_in_field_declaration470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000808400080) };
static  ANTLR3_BITSET_LIST FOLLOW_READONLY_in_field_declaration470	= { FOLLOW_READONLY_in_field_declaration470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_field_declaration475  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_field_declaration475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000060080) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_field_declaration475	= { FOLLOW_type_declaration_in_field_declaration475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_field_declaration477  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_field_declaration477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_field_declaration477	= { FOLLOW_identifier_in_field_declaration477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_field_declaration479  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_field_declaration479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_field_declaration479	= { FOLLOW_SEMICOLON_in_field_declaration479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_declaration_in_class_member507  */
static	ANTLR3_BITWORD FOLLOW_method_declaration_in_class_member507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_method_declaration_in_class_member507	= { FOLLOW_method_declaration_in_class_member507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_record_member_in_class_member512  */
static	ANTLR3_BITWORD FOLLOW_record_member_in_class_member512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_record_member_in_class_member512	= { FOLLOW_record_member_in_class_member512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_type_spec_in_method_declaration525  */
static	ANTLR3_BITWORD FOLLOW_method_type_spec_in_method_declaration525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_method_type_spec_in_method_declaration525	= { FOLLOW_method_type_spec_in_method_declaration525_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_method_declaration527  */
static	ANTLR3_BITWORD FOLLOW_ID_in_method_declaration527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_method_declaration527	= { FOLLOW_ID_in_method_declaration527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_PAREN_in_method_declaration529  */
static	ANTLR3_BITWORD FOLLOW_OPEN_PAREN_in_method_declaration529_bits[]	= { ANTLR3_UINT64_LIT(0x00000001C0010000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_PAREN_in_method_declaration529	= { FOLLOW_OPEN_PAREN_in_method_declaration529_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_list_in_method_declaration537  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_list_in_method_declaration537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_list_in_method_declaration537	= { FOLLOW_parameter_declaration_list_in_method_declaration537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_PAREN_in_method_declaration540  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_PAREN_in_method_declaration540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800020) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_PAREN_in_method_declaration540	= { FOLLOW_CLOSE_PAREN_in_method_declaration540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exception_list_in_method_declaration544  */
static	ANTLR3_BITWORD FOLLOW_exception_list_in_method_declaration544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_exception_list_in_method_declaration544	= { FOLLOW_exception_list_in_method_declaration544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_method_declaration547  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_method_declaration547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_method_declaration547	= { FOLLOW_SEMICOLON_in_method_declaration547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_in_parameter_declaration_list560  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_in_parameter_declaration_list560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_in_parameter_declaration_list560	= { FOLLOW_parameter_declaration_in_parameter_declaration_list560_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_parameter_declaration_list564  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_parameter_declaration_list564_bits[]	= { ANTLR3_UINT64_LIT(0x00000001C0000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_parameter_declaration_list564	= { FOLLOW_COMMA_in_parameter_declaration_list564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_declaration_in_parameter_declaration_list566  */
static	ANTLR3_BITWORD FOLLOW_parameter_declaration_in_parameter_declaration_list566_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_declaration_in_parameter_declaration_list566	= { FOLLOW_parameter_declaration_in_parameter_declaration_list566_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_io_in_parameter_declaration580  */
static	ANTLR3_BITWORD FOLLOW_param_io_in_parameter_declaration580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000808400080) };
static  ANTLR3_BITSET_LIST FOLLOW_param_io_in_parameter_declaration580	= { FOLLOW_param_io_in_parameter_declaration580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_parameter_declaration582  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_parameter_declaration582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_parameter_declaration582	= { FOLLOW_type_declaration_in_parameter_declaration582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_parameter_declaration584  */
static	ANTLR3_BITWORD FOLLOW_ID_in_parameter_declaration584_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_parameter_declaration584	= { FOLLOW_ID_in_parameter_declaration584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RAISES_in_exception_list599  */
static	ANTLR3_BITWORD FOLLOW_RAISES_in_exception_list599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_RAISES_in_exception_list599	= { FOLLOW_RAISES_in_exception_list599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_identifier_in_exception_list605  */
static	ANTLR3_BITWORD FOLLOW_qualified_identifier_in_exception_list605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_identifier_in_exception_list605	= { FOLLOW_qualified_identifier_in_exception_list605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_exception_list615  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_exception_list615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_exception_list615	= { FOLLOW_COMMA_in_exception_list615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_identifier_in_exception_list619  */
static	ANTLR3_BITWORD FOLLOW_qualified_identifier_in_exception_list619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_identifier_in_exception_list619	= { FOLLOW_qualified_identifier_in_exception_list619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CPP_BLOCK_in_interface_member635  */
static	ANTLR3_BITWORD FOLLOW_CPP_BLOCK_in_interface_member635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CPP_BLOCK_in_interface_member635	= { FOLLOW_CPP_BLOCK_in_interface_member635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_class_member_in_interface_member642  */
static	ANTLR3_BITWORD FOLLOW_class_member_in_interface_member642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_class_member_in_interface_member642	= { FOLLOW_class_member_in_interface_member642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTENDS_in_inheritance_declaration653  */
static	ANTLR3_BITWORD FOLLOW_EXTENDS_in_inheritance_declaration653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTENDS_in_inheritance_declaration653	= { FOLLOW_EXTENDS_in_inheritance_declaration653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_identifier_in_inheritance_declaration659  */
static	ANTLR3_BITWORD FOLLOW_qualified_identifier_in_inheritance_declaration659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_identifier_in_inheritance_declaration659	= { FOLLOW_qualified_identifier_in_inheritance_declaration659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_component_member674  */
static	ANTLR3_BITWORD FOLLOW_comment_in_component_member674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_component_member674	= { FOLLOW_comment_in_component_member674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interface_role_in_component_member681  */
static	ANTLR3_BITWORD FOLLOW_interface_role_in_component_member681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_interface_role_in_component_member681	= { FOLLOW_interface_role_in_component_member681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_identifier_in_component_member683  */
static	ANTLR3_BITWORD FOLLOW_qualified_identifier_in_component_member683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_identifier_in_component_member683	= { FOLLOW_qualified_identifier_in_component_member683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_component_member691  */
static	ANTLR3_BITWORD FOLLOW_ID_in_component_member691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_component_member691	= { FOLLOW_ID_in_component_member691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMICOLON_in_component_member693  */
static	ANTLR3_BITWORD FOLLOW_SEMICOLON_in_component_member693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMICOLON_in_component_member693	= { FOLLOW_SEMICOLON_in_component_member693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TOK_VOID_in_method_type_spec708  */
static	ANTLR3_BITWORD FOLLOW_TOK_VOID_in_method_type_spec708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TOK_VOID_in_method_type_spec708	= { FOLLOW_TOK_VOID_in_method_type_spec708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_method_type_spec717  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_method_type_spec717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_method_type_spec717	= { FOLLOW_type_declaration_in_method_type_spec717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BASIC_TYPE_in_type_declaration747  */
static	ANTLR3_BITWORD FOLLOW_BASIC_TYPE_in_type_declaration747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BASIC_TYPE_in_type_declaration747	= { FOLLOW_BASIC_TYPE_in_type_declaration747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualified_identifier_in_type_declaration756  */
static	ANTLR3_BITWORD FOLLOW_qualified_identifier_in_type_declaration756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualified_identifier_in_type_declaration756	= { FOLLOW_qualified_identifier_in_type_declaration756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pair_of_braces_in_type_declaration768  */
static	ANTLR3_BITWORD FOLLOW_pair_of_braces_in_type_declaration768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pair_of_braces_in_type_declaration768	= { FOLLOW_pair_of_braces_in_type_declaration768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_BRACE_in_pair_of_braces793  */
static	ANTLR3_BITWORD FOLLOW_OPEN_BRACE_in_pair_of_braces793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_BRACE_in_pair_of_braces793	= { FOLLOW_OPEN_BRACE_in_pair_of_braces793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSE_BRACE_in_pair_of_braces795  */
static	ANTLR3_BITWORD FOLLOW_CLOSE_BRACE_in_pair_of_braces795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSE_BRACE_in_pair_of_braces795	= { FOLLOW_CLOSE_BRACE_in_pair_of_braces795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TOK_IN_in_param_io816  */
static	ANTLR3_BITWORD FOLLOW_TOK_IN_in_param_io816_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TOK_IN_in_param_io816	= { FOLLOW_TOK_IN_in_param_io816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TOK_OUT_in_param_io822  */
static	ANTLR3_BITWORD FOLLOW_TOK_OUT_in_param_io822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TOK_OUT_in_param_io822	= { FOLLOW_TOK_OUT_in_param_io822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TOK_INOUT_in_param_io828  */
static	ANTLR3_BITWORD FOLLOW_TOK_INOUT_in_param_io828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TOK_INOUT_in_param_io828	= { FOLLOW_TOK_INOUT_in_param_io828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROVIDES_in_interface_role844  */
static	ANTLR3_BITWORD FOLLOW_PROVIDES_in_interface_role844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PROVIDES_in_interface_role844	= { FOLLOW_PROVIDES_in_interface_role844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RECEIVES_in_interface_role851  */
static	ANTLR3_BITWORD FOLLOW_RECEIVES_in_interface_role851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RECEIVES_in_interface_role851	= { FOLLOW_RECEIVES_in_interface_role851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMENT_in_comment864  */
static	ANTLR3_BITWORD FOLLOW_COMMENT_in_comment864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMENT_in_comment864	= { FOLLOW_COMMENT_in_comment864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_type_spec_in_synpred1_CSL498  */
static	ANTLR3_BITWORD FOLLOW_method_type_spec_in_synpred1_CSL498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_method_type_spec_in_synpred1_CSL498	= { FOLLOW_method_type_spec_in_synpred1_CSL498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_synpred1_CSL500  */
static	ANTLR3_BITWORD FOLLOW_ID_in_synpred1_CSL500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_synpred1_CSL500	= { FOLLOW_ID_in_synpred1_CSL500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPEN_PAREN_in_synpred1_CSL502  */
static	ANTLR3_BITWORD FOLLOW_OPEN_PAREN_in_synpred1_CSL502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPEN_PAREN_in_synpred1_CSL502	= { FOLLOW_OPEN_PAREN_in_synpred1_CSL502_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start csl_file
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:31:1: csl_file : ( specification )+ EOF ;
 */
static void
csl_file(pCSLParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:36:2: ( ( specification )+ EOF )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:36:4: ( specification )+ EOF
        {
            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:36:4: ( specification )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) ) 
            	{
            	case IMPORT:
            	case EXCEPTION_TOKEN:
            	case ENUM:
            	case STRUCT:
            	case NATIVE:
            	case INTERFACE:
            	case COMPONENT:
            	case COMMENT:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1) 
            	{
            	    case 1:
            	        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:36:4: specification
            	        {
            	            FOLLOWPUSH(FOLLOW_specification_in_csl_file70);
            	            specification(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecsl_fileEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulecsl_fileEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }
             MATCHT(EOF, &FOLLOW_EOF_in_csl_file73); 
            if  (HASEXCEPTION())
            {
                goto rulecsl_fileEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecsl_fileEx; /* Prevent compiler warnings */
    rulecsl_fileEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end csl_file */

/** 
 * $ANTLR start specification
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:39:1: specification : ( comment | import_clause | enum_specification | exception_specification | struct_specification | native_class_specification | interface_specification | component_specification );
 */
static void
specification(pCSLParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:40:2: ( comment | import_clause | enum_specification | exception_specification | struct_specification | native_class_specification | interface_specification | component_specification )
            
            ANTLR3_UINT32 alt2;

            alt2=8;

            switch ( LA(1) ) 
            {
            case COMMENT:
            	{
            		alt2=1;
            	}
                break;
            case IMPORT:
            	{
            		alt2=2;
            	}
                break;
            case ENUM:
            	{
            		alt2=3;
            	}
                break;
            case EXCEPTION_TOKEN:
            	{
            		alt2=4;
            	}
                break;
            case STRUCT:
            	{
            		alt2=5;
            	}
                break;
            case NATIVE:
            	{
            		alt2=6;
            	}
                break;
            case INTERFACE:
            	{
            		alt2=7;
            	}
                break;
            case COMPONENT:
            	{
            		alt2=8;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto rulespecificationEx;
            }

            switch (alt2) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:40:4: comment
        	    {
        	        FOLLOWPUSH(FOLLOW_comment_in_specification84);
        	        comment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:41:4: import_clause
        	    {
        	        FOLLOWPUSH(FOLLOW_import_clause_in_specification89);
        	        import_clause(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:42:4: enum_specification
        	    {
        	        FOLLOWPUSH(FOLLOW_enum_specification_in_specification94);
        	        enum_specification(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:43:4: exception_specification
        	    {
        	        FOLLOWPUSH(FOLLOW_exception_specification_in_specification99);
        	        exception_specification(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 5:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:44:4: struct_specification
        	    {
        	        FOLLOWPUSH(FOLLOW_struct_specification_in_specification104);
        	        struct_specification(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 6:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:45:4: native_class_specification
        	    {
        	        FOLLOWPUSH(FOLLOW_native_class_specification_in_specification109);
        	        native_class_specification(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 7:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:46:4: interface_specification
        	    {
        	        FOLLOWPUSH(FOLLOW_interface_specification_in_specification114);
        	        interface_specification(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 8:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:47:4: component_specification
        	    {
        	        FOLLOWPUSH(FOLLOW_component_specification_in_specification119);
        	        component_specification(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulespecificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulespecificationEx; /* Prevent compiler warnings */
    rulespecificationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end specification */

/** 
 * $ANTLR start import_clause
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:50:1: import_clause : IMPORT qualified_identifier SEMICOLON ;
 */
static void
import_clause(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    IMPORT1;
    CSLParser_qualified_identifier_return qualified_identifier2;
    #undef	RETURN_TYPE_qualified_identifier2
    #define	RETURN_TYPE_qualified_identifier2 CSLParser_qualified_identifier_return

    /* Initialize rule variables
     */


    IMPORT1       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:51:2: ( IMPORT qualified_identifier SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:51:4: IMPORT qualified_identifier SEMICOLON
        {
            IMPORT1 = (pANTLR3_COMMON_TOKEN) MATCHT(IMPORT, &FOLLOW_IMPORT_in_import_clause130); 
            if  (HASEXCEPTION())
            {
                goto ruleimport_clauseEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (IMPORT1->getLine(IMPORT1)) ); 
            }
            FOLLOWPUSH(FOLLOW_qualified_identifier_in_import_clause134);
            qualified_identifier2=qualified_identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleimport_clauseEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_import_clause136); 
            if  (HASEXCEPTION())
            {
                goto ruleimport_clauseEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onImportClause( (const char*)(STRSTREAM->toStringTT(STRSTREAM, qualified_identifier2.start, qualified_identifier2.stop))->chars );
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleimport_clauseEx; /* Prevent compiler warnings */
    ruleimport_clauseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end import_clause */

/** 
 * $ANTLR start exception_specification
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:57:1: exception_specification : EXCEPTION_TOKEN ID SEMICOLON ;
 */
static void
exception_specification(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    EXCEPTION_TOKEN3;
    pANTLR3_COMMON_TOKEN    ID4;

    /* Initialize rule variables
     */


    EXCEPTION_TOKEN3       = NULL;
    ID4       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:58:2: ( EXCEPTION_TOKEN ID SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:58:4: EXCEPTION_TOKEN ID SEMICOLON
        {
            EXCEPTION_TOKEN3 = (pANTLR3_COMMON_TOKEN) MATCHT(EXCEPTION_TOKEN, &FOLLOW_EXCEPTION_TOKEN_in_exception_specification151); 
            if  (HASEXCEPTION())
            {
                goto ruleexception_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (EXCEPTION_TOKEN3->getLine(EXCEPTION_TOKEN3)) ); 
            }
            ID4 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_exception_specification155); 
            if  (HASEXCEPTION())
            {
                goto ruleexception_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_exception_specification157); 
            if  (HASEXCEPTION())
            {
                goto ruleexception_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onTypeSpecification( (const char*)(ID4->getText(ID4))->chars, co::TK_EXCEPTION );
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexception_specificationEx; /* Prevent compiler warnings */
    ruleexception_specificationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end exception_specification */

/** 
 * $ANTLR start enum_specification
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:64:1: enum_specification : ENUM ID OPEN_BLOCK identifier_list CLOSE_BLOCK SEMICOLON ;
 */
static void
enum_specification(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    ENUM5;
    pANTLR3_COMMON_TOKEN    ID6;

    /* Initialize rule variables
     */


    ENUM5       = NULL;
    ID6       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:65:2: ( ENUM ID OPEN_BLOCK identifier_list CLOSE_BLOCK SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:65:4: ENUM ID OPEN_BLOCK identifier_list CLOSE_BLOCK SEMICOLON
        {
            ENUM5 = (pANTLR3_COMMON_TOKEN) MATCHT(ENUM, &FOLLOW_ENUM_in_enum_specification172); 
            if  (HASEXCEPTION())
            {
                goto ruleenum_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (ENUM5->getLine(ENUM5)) ); 
            }
            ID6 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_enum_specification176); 
            if  (HASEXCEPTION())
            {
                goto ruleenum_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onTypeSpecification( (const char*)(ID6->getText(ID6))->chars, co::TK_ENUM );
                		
            }
             MATCHT(OPEN_BLOCK, &FOLLOW_OPEN_BLOCK_in_enum_specification184); 
            if  (HASEXCEPTION())
            {
                goto ruleenum_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_identifier_list_in_enum_specification186);
            identifier_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenum_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(CLOSE_BLOCK, &FOLLOW_CLOSE_BLOCK_in_enum_specification188); 
            if  (HASEXCEPTION())
            {
                goto ruleenum_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_enum_specification190); 
            if  (HASEXCEPTION())
            {
                goto ruleenum_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenum_specificationEx; /* Prevent compiler warnings */
    ruleenum_specificationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end enum_specification */

/** 
 * $ANTLR start struct_specification
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:72:1: struct_specification : STRUCT ID OPEN_BLOCK ( record_member )* CLOSE_BLOCK SEMICOLON ;
 */
static void
struct_specification(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    STRUCT7;
    pANTLR3_COMMON_TOKEN    ID8;

    /* Initialize rule variables
     */


    STRUCT7       = NULL;
    ID8       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:73:2: ( STRUCT ID OPEN_BLOCK ( record_member )* CLOSE_BLOCK SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:73:4: STRUCT ID OPEN_BLOCK ( record_member )* CLOSE_BLOCK SEMICOLON
        {
            STRUCT7 = (pANTLR3_COMMON_TOKEN) MATCHT(STRUCT, &FOLLOW_STRUCT_in_struct_specification201); 
            if  (HASEXCEPTION())
            {
                goto rulestruct_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (STRUCT7->getLine(STRUCT7)) ); 
            }
            ID8 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_struct_specification205); 
            if  (HASEXCEPTION())
            {
                goto rulestruct_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onTypeSpecification( (const char*)(ID8->getText(ID8))->chars, co::TK_STRUCT );
                		
            }
             MATCHT(OPEN_BLOCK, &FOLLOW_OPEN_BLOCK_in_struct_specification213); 
            if  (HASEXCEPTION())
            {
                goto rulestruct_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:77:14: ( record_member )*

            for (;;)
            {
                int alt3=2;
                switch ( LA(1) ) 
                {
                case ID:
                case READONLY:
                case BASIC_TYPE:
                case COMMENT:
                	{
                		alt3=1;
                	}
                    break;

                }

                switch (alt3) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:77:14: record_member
            	    {
            	        FOLLOWPUSH(FOLLOW_record_member_in_struct_specification215);
            	        record_member(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestruct_specificationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */

             MATCHT(CLOSE_BLOCK, &FOLLOW_CLOSE_BLOCK_in_struct_specification218); 
            if  (HASEXCEPTION())
            {
                goto rulestruct_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_struct_specification220); 
            if  (HASEXCEPTION())
            {
                goto rulestruct_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestruct_specificationEx; /* Prevent compiler warnings */
    rulestruct_specificationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end struct_specification */

/** 
 * $ANTLR start native_class_specification
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:80:1: native_class_specification : NATIVE CLASS ID OPEN_PAREN CPP_TAG cpp_type CLOSE_PAREN OPEN_BLOCK ( class_member )* CLOSE_BLOCK SEMICOLON ;
 */
static void
native_class_specification(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    NATIVE9;
    pANTLR3_COMMON_TOKEN    ID10;
    pANTLR3_COMMON_TOKEN    CPP_TAG11;
    CSLParser_cpp_type_return cpp_type12;
    #undef	RETURN_TYPE_cpp_type12
    #define	RETURN_TYPE_cpp_type12 CSLParser_cpp_type_return

    /* Initialize rule variables
     */


    NATIVE9       = NULL;
    ID10       = NULL;
    CPP_TAG11       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:81:2: ( NATIVE CLASS ID OPEN_PAREN CPP_TAG cpp_type CLOSE_PAREN OPEN_BLOCK ( class_member )* CLOSE_BLOCK SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:81:4: NATIVE CLASS ID OPEN_PAREN CPP_TAG cpp_type CLOSE_PAREN OPEN_BLOCK ( class_member )* CLOSE_BLOCK SEMICOLON
        {
            NATIVE9 = (pANTLR3_COMMON_TOKEN) MATCHT(NATIVE, &FOLLOW_NATIVE_in_native_class_specification231); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (NATIVE9->getLine(NATIVE9)) ); 
            }
             MATCHT(CLASS, &FOLLOW_CLASS_in_native_class_specification235); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            ID10 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_native_class_specification237); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onTypeSpecification( (const char*)(ID10->getText(ID10))->chars, co::TK_NATIVECLASS );
                		
            }
             MATCHT(OPEN_PAREN, &FOLLOW_OPEN_PAREN_in_native_class_specification245); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            CPP_TAG11 = (pANTLR3_COMMON_TOKEN) MATCHT(CPP_TAG, &FOLLOW_CPP_TAG_in_native_class_specification247); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_cpp_type_in_native_class_specification249);
            cpp_type12=cpp_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(CLOSE_PAREN, &FOLLOW_CLOSE_PAREN_in_native_class_specification251); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onNativeClass( (const char*)(CPP_TAG11->getText(CPP_TAG11))->chars, (const char*)(STRSTREAM->toStringTT(STRSTREAM, cpp_type12.start, cpp_type12.stop))->chars );
                		
            }
             MATCHT(OPEN_BLOCK, &FOLLOW_OPEN_BLOCK_in_native_class_specification259); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:89:14: ( class_member )*

            for (;;)
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                case ID:
                case READONLY:
                case TOK_VOID:
                case BASIC_TYPE:
                case COMMENT:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:89:14: class_member
            	    {
            	        FOLLOWPUSH(FOLLOW_class_member_in_native_class_specification261);
            	        class_member(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenative_class_specificationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */

             MATCHT(CLOSE_BLOCK, &FOLLOW_CLOSE_BLOCK_in_native_class_specification264); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_native_class_specification266); 
            if  (HASEXCEPTION())
            {
                goto rulenative_class_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenative_class_specificationEx; /* Prevent compiler warnings */
    rulenative_class_specificationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end native_class_specification */

/** 
 * $ANTLR start interface_specification
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:92:1: interface_specification : INTERFACE ID ( inheritance_declaration )? OPEN_BLOCK ( interface_member )* CLOSE_BLOCK SEMICOLON ;
 */
static void
interface_specification(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    INTERFACE13;
    pANTLR3_COMMON_TOKEN    ID14;

    /* Initialize rule variables
     */


    INTERFACE13       = NULL;
    ID14       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:93:2: ( INTERFACE ID ( inheritance_declaration )? OPEN_BLOCK ( interface_member )* CLOSE_BLOCK SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:93:4: INTERFACE ID ( inheritance_declaration )? OPEN_BLOCK ( interface_member )* CLOSE_BLOCK SEMICOLON
        {
            INTERFACE13 = (pANTLR3_COMMON_TOKEN) MATCHT(INTERFACE, &FOLLOW_INTERFACE_in_interface_specification277); 
            if  (HASEXCEPTION())
            {
                goto ruleinterface_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (INTERFACE13->getLine(INTERFACE13)) ); 
            }
            ID14 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_interface_specification281); 
            if  (HASEXCEPTION())
            {
                goto ruleinterface_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onTypeSpecification( (const char*)(ID14->getText(ID14))->chars, co::TK_INTERFACE );
                		
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:97:3: ( inheritance_declaration )?
            {
                int alt5=2;
                switch ( LA(1) ) 
                {
                    case EXTENDS:
                    	{
                    		alt5=1;
                    	}
                        break;
                }

                switch (alt5) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:97:3: inheritance_declaration
            	    {
            	        FOLLOWPUSH(FOLLOW_inheritance_declaration_in_interface_specification289);
            	        inheritance_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinterface_specificationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(OPEN_BLOCK, &FOLLOW_OPEN_BLOCK_in_interface_specification292); 
            if  (HASEXCEPTION())
            {
                goto ruleinterface_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:97:39: ( interface_member )*

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) ) 
                {
                case ID:
                case READONLY:
                case CPP_BLOCK:
                case TOK_VOID:
                case BASIC_TYPE:
                case COMMENT:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:97:39: interface_member
            	    {
            	        FOLLOWPUSH(FOLLOW_interface_member_in_interface_specification294);
            	        interface_member(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleinterface_specificationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */

             MATCHT(CLOSE_BLOCK, &FOLLOW_CLOSE_BLOCK_in_interface_specification297); 
            if  (HASEXCEPTION())
            {
                goto ruleinterface_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_interface_specification299); 
            if  (HASEXCEPTION())
            {
                goto ruleinterface_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleinterface_specificationEx; /* Prevent compiler warnings */
    ruleinterface_specificationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end interface_specification */

/** 
 * $ANTLR start component_specification
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:100:1: component_specification : COMPONENT ID OPEN_BLOCK ( component_member )* CLOSE_BLOCK SEMICOLON ;
 */
static void
component_specification(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    COMPONENT15;
    pANTLR3_COMMON_TOKEN    ID16;

    /* Initialize rule variables
     */


    COMPONENT15       = NULL;
    ID16       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:101:2: ( COMPONENT ID OPEN_BLOCK ( component_member )* CLOSE_BLOCK SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:101:4: COMPONENT ID OPEN_BLOCK ( component_member )* CLOSE_BLOCK SEMICOLON
        {
            COMPONENT15 = (pANTLR3_COMMON_TOKEN) MATCHT(COMPONENT, &FOLLOW_COMPONENT_in_component_specification310); 
            if  (HASEXCEPTION())
            {
                goto rulecomponent_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (COMPONENT15->getLine(COMPONENT15)) ); 
            }
            ID16 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_component_specification314); 
            if  (HASEXCEPTION())
            {
                goto rulecomponent_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onTypeSpecification( (const char*)(ID16->getText(ID16))->chars, co::TK_COMPONENT  );
                		
            }
             MATCHT(OPEN_BLOCK, &FOLLOW_OPEN_BLOCK_in_component_specification322); 
            if  (HASEXCEPTION())
            {
                goto rulecomponent_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:105:14: ( component_member )*

            for (;;)
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                case PROVIDES:
                case RECEIVES:
                case COMMENT:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:105:14: component_member
            	    {
            	        FOLLOWPUSH(FOLLOW_component_member_in_component_specification324);
            	        component_member(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponent_specificationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */

             MATCHT(CLOSE_BLOCK, &FOLLOW_CLOSE_BLOCK_in_component_specification327); 
            if  (HASEXCEPTION())
            {
                goto rulecomponent_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_component_specification329); 
            if  (HASEXCEPTION())
            {
                goto rulecomponent_specificationEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponent_specificationEx; /* Prevent compiler warnings */
    rulecomponent_specificationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end component_specification */

/** 
 * $ANTLR start identifier
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:108:1: identifier : ( ID | COMPONENT | INTERFACE );
 */
static CSLParser_identifier_return
identifier(pCSLParser ctx)
{   
    CSLParser_identifier_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:109:2: ( ID | COMPONENT | INTERFACE )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:
        {
            if ( LA(1) == ID || ((LA(1) >= INTERFACE) && (LA(1) <= COMPONENT)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_identifier0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_identifier0);    goto ruleidentifierEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end identifier */

/** 
 * $ANTLR start qualified_identifier
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:114:1: qualified_identifier : ID ( DOT ID )* ;
 */
static CSLParser_qualified_identifier_return
qualified_identifier(pCSLParser ctx)
{   
    CSLParser_qualified_identifier_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:115:2: ( ID ( DOT ID )* )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:115:4: ID ( DOT ID )*
        {
             MATCHT(ID, &FOLLOW_ID_in_qualified_identifier361); 
            if  (HASEXCEPTION())
            {
                goto rulequalified_identifierEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:115:7: ( DOT ID )*

            for (;;)
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                case DOT:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:115:9: DOT ID
            	    {
            	         MATCHT(DOT, &FOLLOW_DOT_in_qualified_identifier365); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalified_identifierEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         MATCHT(ID, &FOLLOW_ID_in_qualified_identifier367); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulequalified_identifierEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequalified_identifierEx; /* Prevent compiler warnings */
    rulequalified_identifierEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end qualified_identifier */

/** 
 * $ANTLR start cpp_type
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:118:1: cpp_type : ID ( CPP_SCOPE ID )* ( CPP_TAG )? ;
 */
static CSLParser_cpp_type_return
cpp_type(pCSLParser ctx)
{   
    CSLParser_cpp_type_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:119:2: ( ID ( CPP_SCOPE ID )* ( CPP_TAG )? )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:119:4: ID ( CPP_SCOPE ID )* ( CPP_TAG )?
        {
             MATCHT(ID, &FOLLOW_ID_in_cpp_type381); 
            if  (HASEXCEPTION())
            {
                goto rulecpp_typeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:119:7: ( CPP_SCOPE ID )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                case CPP_SCOPE:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:119:9: CPP_SCOPE ID
            	    {
            	         MATCHT(CPP_SCOPE, &FOLLOW_CPP_SCOPE_in_cpp_type385); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecpp_typeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         MATCHT(ID, &FOLLOW_ID_in_cpp_type387); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecpp_typeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:119:25: ( CPP_TAG )?
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                    case CPP_TAG:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:119:25: CPP_TAG
            	    {
            	         MATCHT(CPP_TAG, &FOLLOW_CPP_TAG_in_cpp_type392); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecpp_typeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecpp_typeEx; /* Prevent compiler warnings */
    rulecpp_typeEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end cpp_type */

/** 
 * $ANTLR start identifier_list
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:122:1: identifier_list : ( comment )* firstId= ID ( COMMA ( comment )* loopId= ID )* ( comment )* ;
 */
static void
identifier_list(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    firstId;
    pANTLR3_COMMON_TOKEN    loopId;

    /* Initialize rule variables
     */


    firstId       = NULL;
    loopId       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:123:2: ( ( comment )* firstId= ID ( COMMA ( comment )* loopId= ID )* ( comment )* )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:123:4: ( comment )* firstId= ID ( COMMA ( comment )* loopId= ID )* ( comment )*
        {

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:123:4: ( comment )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                case COMMENT:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:123:4: comment
            	    {
            	        FOLLOWPUSH(FOLLOW_comment_in_identifier_list404);
            	        comment(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifier_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */

            firstId = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_identifier_list411); 
            if  (HASEXCEPTION())
            {
                goto ruleidentifier_listEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->setCurrentLine( (firstId->getLine(firstId)) );
                			ctx->parser->onIdentifierListItem( (const char*)(firstId->getText(firstId))->chars );
                		
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:128:3: ( COMMA ( comment )* loopId= ID )*

            for (;;)
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt13=1;
                	}
                    break;

                }

                switch (alt13) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:128:5: COMMA ( comment )* loopId= ID
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_identifier_list421); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifier_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:128:11: ( comment )*

            	        for (;;)
            	        {
            	            int alt12=2;
            	            switch ( LA(1) ) 
            	            {
            	            case COMMENT:
            	            	{
            	            		alt12=1;
            	            	}
            	                break;

            	            }

            	            switch (alt12) 
            	            {
            	        	case 1:
            	        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:128:11: comment
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_comment_in_identifier_list423);
            	        	        comment(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleidentifier_listEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop12;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop12: ; /* Jump out to here if this rule does not match */

            	        loopId = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_identifier_list430); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifier_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	            				ctx->parser->setCurrentLine( (loopId->getLine(loopId)) );
            	            				ctx->parser->onIdentifierListItem( (const char*)(loopId->getText(loopId))->chars );
            	            			
            	        }

            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:133:6: ( comment )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                case COMMENT:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:133:6: comment
            	    {
            	        FOLLOWPUSH(FOLLOW_comment_in_identifier_list442);
            	        comment(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleidentifier_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleidentifier_listEx; /* Prevent compiler warnings */
    ruleidentifier_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end identifier_list */

/** 
 * $ANTLR start record_member
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:136:1: record_member : ( comment | field_declaration );
 */
static void
record_member(pCSLParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:137:2: ( comment | field_declaration )
            
            ANTLR3_UINT32 alt15;

            alt15=2;

            switch ( LA(1) ) 
            {
            case COMMENT:
            	{
            		alt15=1;
            	}
                break;
            case ID:
            case READONLY:
            case BASIC_TYPE:
            	{
            		alt15=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto rulerecord_memberEx;
            }

            switch (alt15) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:137:4: comment
        	    {
        	        FOLLOWPUSH(FOLLOW_comment_in_record_member454);
        	        comment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerecord_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:138:4: field_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_field_declaration_in_record_member459);
        	        field_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerecord_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulerecord_memberEx; /* Prevent compiler warnings */
    rulerecord_memberEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end record_member */

/** 
 * $ANTLR start field_declaration
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:141:1: field_declaration : ( READONLY )? type_declaration identifier SEMICOLON ;
 */
static CSLParser_field_declaration_return
field_declaration(pCSLParser ctx)
{   
    CSLParser_field_declaration_return retval;

    pANTLR3_COMMON_TOKEN    READONLY17;
    CSLParser_identifier_return identifier18;
    #undef	RETURN_TYPE_identifier18
    #define	RETURN_TYPE_identifier18 CSLParser_identifier_return

    /* Initialize rule variables
     */


    READONLY17       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:142:2: ( ( READONLY )? type_declaration identifier SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:142:4: ( READONLY )? type_declaration identifier SEMICOLON
        {

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:142:4: ( READONLY )?
            {
                int alt16=2;
                switch ( LA(1) ) 
                {
                    case READONLY:
                    	{
                    		alt16=1;
                    	}
                        break;
                }

                switch (alt16) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:142:4: READONLY
            	    {
            	        READONLY17 = (pANTLR3_COMMON_TOKEN) MATCHT(READONLY, &FOLLOW_READONLY_in_field_declaration470); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefield_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( retval.start->line ); 
            }
            FOLLOWPUSH(FOLLOW_type_declaration_in_field_declaration475);
            type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefield_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_identifier_in_field_declaration477);
            identifier18=identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefield_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_field_declaration479); 
            if  (HASEXCEPTION())
            {
                goto rulefield_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {

                			bool isReadOnly = false;
                			if( READONLY17 )
                				isReadOnly = true;
                			ctx->parser->onField( (const char*)(STRSTREAM->toStringTT(STRSTREAM, identifier18.start, identifier18.stop))->chars, isReadOnly );
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefield_declarationEx; /* Prevent compiler warnings */
    rulefield_declarationEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end field_declaration */

/** 
 * $ANTLR start class_member
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:151:1: class_member : ( ( method_type_spec ID OPEN_PAREN )=> method_declaration | record_member );
 */
static void
class_member(pCSLParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:153:2: ( ( method_type_spec ID OPEN_PAREN )=> method_declaration | record_member )
            
            ANTLR3_UINT32 alt17;

            alt17=2;


            {
                int LA17_0 = LA(1);
                if ( (synpred1_CSL(ctx)) && (LA17_0 == TOK_VOID)) 
                {
                    alt17=1;
                }
                else if ( (LA17_0 == BASIC_TYPE)) 
                {

                    {
                        int LA17_2 = LA(2);
                        if ( (synpred1_CSL(ctx))) 
                        {
                            alt17=1;
                        }
                        else if ( (ANTLR3_TRUE)) 
                        {
                            alt17=2;
                        }
                        else 
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 17;
                            EXCEPTION->state        = 2;


                            goto ruleclass_memberEx;
                        }
                    }
                }
                else if ( (LA17_0 == ID)) 
                {

                    {
                        int LA17_3 = LA(2);
                        if ( (synpred1_CSL(ctx))) 
                        {
                            alt17=1;
                        }
                        else if ( (ANTLR3_TRUE)) 
                        {
                            alt17=2;
                        }
                        else 
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 17;
                            EXCEPTION->state        = 3;


                            goto ruleclass_memberEx;
                        }
                    }
                }
                else if ( (LA17_0 == READONLY || LA17_0 == COMMENT)) 
                {
                    alt17=2;
                }
                else 
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 17;
                    EXCEPTION->state        = 0;


                    goto ruleclass_memberEx;
                }
            }
            switch (alt17) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:153:4: ( method_type_spec ID OPEN_PAREN )=> method_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_method_declaration_in_class_member507);
        	        method_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclass_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:154:4: record_member
        	    {
        	        FOLLOWPUSH(FOLLOW_record_member_in_class_member512);
        	        record_member(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleclass_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleclass_memberEx; /* Prevent compiler warnings */
    ruleclass_memberEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end class_member */

/** 
 * $ANTLR start method_declaration
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:157:1: method_declaration : method_type_spec ID OPEN_PAREN ( parameter_declaration_list )? CLOSE_PAREN ( exception_list )? SEMICOLON ;
 */
static CSLParser_method_declaration_return
method_declaration(pCSLParser ctx)
{   
    CSLParser_method_declaration_return retval;

    pANTLR3_COMMON_TOKEN    ID19;

    /* Initialize rule variables
     */


    ID19       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:158:2: ( method_type_spec ID OPEN_PAREN ( parameter_declaration_list )? CLOSE_PAREN ( exception_list )? SEMICOLON )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:158:4: method_type_spec ID OPEN_PAREN ( parameter_declaration_list )? CLOSE_PAREN ( exception_list )? SEMICOLON
        {
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( retval.start->line ); 
            }
            FOLLOWPUSH(FOLLOW_method_type_spec_in_method_declaration525);
            method_type_spec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemethod_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            ID19 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_method_declaration527); 
            if  (HASEXCEPTION())
            {
                goto rulemethod_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(OPEN_PAREN, &FOLLOW_OPEN_PAREN_in_method_declaration529); 
            if  (HASEXCEPTION())
            {
                goto rulemethod_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onMethod( (char*)(ID19->getText(ID19))->chars );
                		
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:162:3: ( parameter_declaration_list )?
            {
                int alt18=2;
                switch ( LA(1) ) 
                {
                    case TOK_IN:
                    case TOK_OUT:
                    case TOK_INOUT:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:162:3: parameter_declaration_list
            	    {
            	        FOLLOWPUSH(FOLLOW_parameter_declaration_list_in_method_declaration537);
            	        parameter_declaration_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethod_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(CLOSE_PAREN, &FOLLOW_CLOSE_PAREN_in_method_declaration540); 
            if  (HASEXCEPTION())
            {
                goto rulemethod_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:163:3: ( exception_list )?
            {
                int alt19=2;
                switch ( LA(1) ) 
                {
                    case RAISES:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:163:3: exception_list
            	    {
            	        FOLLOWPUSH(FOLLOW_exception_list_in_method_declaration544);
            	        exception_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethod_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_method_declaration547); 
            if  (HASEXCEPTION())
            {
                goto rulemethod_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->onEndMethod(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemethod_declarationEx; /* Prevent compiler warnings */
    rulemethod_declarationEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end method_declaration */

/** 
 * $ANTLR start parameter_declaration_list
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:166:1: parameter_declaration_list : parameter_declaration ( COMMA parameter_declaration )* ;
 */
static void
parameter_declaration_list(pCSLParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:167:2: ( parameter_declaration ( COMMA parameter_declaration )* )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:167:4: parameter_declaration ( COMMA parameter_declaration )*
        {
            FOLLOWPUSH(FOLLOW_parameter_declaration_in_parameter_declaration_list560);
            parameter_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declaration_listEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:167:26: ( COMMA parameter_declaration )*

            for (;;)
            {
                int alt20=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:167:28: COMMA parameter_declaration
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_parameter_declaration_list564); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameter_declaration_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_parameter_declaration_in_parameter_declaration_list566);
            	        parameter_declaration(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameter_declaration_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameter_declaration_listEx; /* Prevent compiler warnings */
    ruleparameter_declaration_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end parameter_declaration_list */

/** 
 * $ANTLR start parameter_declaration
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:170:1: parameter_declaration : param_io type_declaration ID ;
 */
static void
parameter_declaration(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    ID21;
    CSLParser_param_io_return param_io20;
    #undef	RETURN_TYPE_param_io20
    #define	RETURN_TYPE_param_io20 CSLParser_param_io_return

    /* Initialize rule variables
     */


    ID21       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:171:2: ( param_io type_declaration ID )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:171:4: param_io type_declaration ID
        {
            FOLLOWPUSH(FOLLOW_param_io_in_parameter_declaration580);
            param_io20=param_io(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_type_declaration_in_parameter_declaration582);
            type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            ID21 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_parameter_declaration584); 
            if  (HASEXCEPTION())
            {
                goto ruleparameter_declarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onParameter( param_io20.isIn, param_io20.isOut, (const char*)(ID21->getText(ID21))->chars );
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameter_declarationEx; /* Prevent compiler warnings */
    ruleparameter_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end parameter_declaration */

/** 
 * $ANTLR start exception_list
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:177:1: exception_list : RAISES firstExcep= qualified_identifier ( COMMA loopExcep= qualified_identifier )* ;
 */
static void
exception_list(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    RAISES22;
    CSLParser_qualified_identifier_return firstExcep;
    #undef	RETURN_TYPE_firstExcep
    #define	RETURN_TYPE_firstExcep CSLParser_qualified_identifier_return

    CSLParser_qualified_identifier_return loopExcep;
    #undef	RETURN_TYPE_loopExcep
    #define	RETURN_TYPE_loopExcep CSLParser_qualified_identifier_return

    /* Initialize rule variables
     */


    RAISES22       = NULL;



    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:178:2: ( RAISES firstExcep= qualified_identifier ( COMMA loopExcep= qualified_identifier )* )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:178:4: RAISES firstExcep= qualified_identifier ( COMMA loopExcep= qualified_identifier )*
        {
            RAISES22 = (pANTLR3_COMMON_TOKEN) MATCHT(RAISES, &FOLLOW_RAISES_in_exception_list599); 
            if  (HASEXCEPTION())
            {
                goto ruleexception_listEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->setCurrentLine( (RAISES22->getLine(RAISES22)) ); 
            }
            FOLLOWPUSH(FOLLOW_qualified_identifier_in_exception_list605);
            firstExcep=qualified_identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexception_listEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onExeptionRaised( (const char*)(STRSTREAM->toStringTT(STRSTREAM, firstExcep.start, firstExcep.stop))->chars );
                		
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:182:3: ( COMMA loopExcep= qualified_identifier )*

            for (;;)
            {
                int alt21=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt21=1;
                	}
                    break;

                }

                switch (alt21) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:182:5: COMMA loopExcep= qualified_identifier
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_exception_list615); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexception_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_qualified_identifier_in_exception_list619);
            	        loopExcep=qualified_identifier(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexception_listEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	             ctx->parser->onExeptionRaised( (const char*)(STRSTREAM->toStringTT(STRSTREAM, loopExcep.start, loopExcep.stop))->chars ); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexception_listEx; /* Prevent compiler warnings */
    ruleexception_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end exception_list */

/** 
 * $ANTLR start interface_member
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:185:1: interface_member : ( CPP_BLOCK | class_member );
 */
static void
interface_member(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    CPP_BLOCK23;

    /* Initialize rule variables
     */


    CPP_BLOCK23       = NULL;

    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:186:2: ( CPP_BLOCK | class_member )
            
            ANTLR3_UINT32 alt22;

            alt22=2;

            switch ( LA(1) ) 
            {
            case CPP_BLOCK:
            	{
            		alt22=1;
            	}
                break;
            case ID:
            case READONLY:
            case TOK_VOID:
            case BASIC_TYPE:
            case COMMENT:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto ruleinterface_memberEx;
            }

            switch (alt22) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:186:4: CPP_BLOCK
        	    {
        	        CPP_BLOCK23 = (pANTLR3_COMMON_TOKEN) MATCHT(CPP_BLOCK, &FOLLOW_CPP_BLOCK_in_interface_member635); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinterface_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             ctx->parser->onCppBlock( (const char*)(CPP_BLOCK23->getText(CPP_BLOCK23))->chars ); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:187:4: class_member
        	    {
        	        FOLLOWPUSH(FOLLOW_class_member_in_interface_member642);
        	        class_member(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinterface_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleinterface_memberEx; /* Prevent compiler warnings */
    ruleinterface_memberEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end interface_member */

/** 
 * $ANTLR start inheritance_declaration
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:190:1: inheritance_declaration : EXTENDS superType= qualified_identifier ;
 */
static void
inheritance_declaration(pCSLParser ctx)
{   
    CSLParser_qualified_identifier_return superType;
    #undef	RETURN_TYPE_superType
    #define	RETURN_TYPE_superType CSLParser_qualified_identifier_return

    /* Initialize rule variables
     */


    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:191:2: ( EXTENDS superType= qualified_identifier )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:191:4: EXTENDS superType= qualified_identifier
        {
             MATCHT(EXTENDS, &FOLLOW_EXTENDS_in_inheritance_declaration653); 
            if  (HASEXCEPTION())
            {
                goto ruleinheritance_declarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_qualified_identifier_in_inheritance_declaration659);
            superType=qualified_identifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinheritance_declarationEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {

                			ctx->parser->onSuperType( (const char*)(STRSTREAM->toStringTT(STRSTREAM, superType.start, superType.stop))->chars );
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleinheritance_declarationEx; /* Prevent compiler warnings */
    ruleinheritance_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end inheritance_declaration */

/** 
 * $ANTLR start component_member
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:197:1: component_member : ( comment | interface_role qualified_identifier ID SEMICOLON );
 */
static CSLParser_component_member_return
component_member(pCSLParser ctx)
{   
    CSLParser_component_member_return retval;

    pANTLR3_COMMON_TOKEN    ID26;
    CSLParser_qualified_identifier_return qualified_identifier24;
    #undef	RETURN_TYPE_qualified_identifier24
    #define	RETURN_TYPE_qualified_identifier24 CSLParser_qualified_identifier_return

    bool interface_role25;
    #undef	RETURN_TYPE_interface_role25
    #define	RETURN_TYPE_interface_role25 bool

    /* Initialize rule variables
     */


    ID26       = NULL;


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:198:2: ( comment | interface_role qualified_identifier ID SEMICOLON )
            
            ANTLR3_UINT32 alt23;

            alt23=2;

            switch ( LA(1) ) 
            {
            case COMMENT:
            	{
            		alt23=1;
            	}
                break;
            case PROVIDES:
            case RECEIVES:
            	{
            		alt23=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto rulecomponent_memberEx;
            }

            switch (alt23) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:198:4: comment
        	    {
        	        FOLLOWPUSH(FOLLOW_comment_in_component_member674);
        	        comment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponent_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:199:4: interface_role qualified_identifier ID SEMICOLON
        	    {
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             ctx->parser->setCurrentLine( retval.start->line ); 
        	        }
        	        FOLLOWPUSH(FOLLOW_interface_role_in_component_member681);
        	        interface_role25=interface_role(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponent_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_qualified_identifier_in_component_member683);
        	        qualified_identifier24=qualified_identifier(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponent_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			ctx->parser->onTypeDeclaration( (const char*)(STRSTREAM->toStringTT(STRSTREAM, qualified_identifier24.start, qualified_identifier24.stop))->chars, false );
        	            		
        	        }
        	        ID26 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_component_member691); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponent_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	         MATCHT(SEMICOLON, &FOLLOW_SEMICOLON_in_component_member693); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponent_memberEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			ctx->parser->onComponentInterface( interface_role25, (const char*)(ID26->getText(ID26))->chars );
        	            		
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponent_memberEx; /* Prevent compiler warnings */
    rulecomponent_memberEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end component_member */

/** 
 * $ANTLR start method_type_spec
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:209:1: method_type_spec : ( TOK_VOID | type_declaration );
 */
static void
method_type_spec(pCSLParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:210:2: ( TOK_VOID | type_declaration )
            
            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) ) 
            {
            case TOK_VOID:
            	{
            		alt24=1;
            	}
                break;
            case ID:
            case BASIC_TYPE:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto rulemethod_type_specEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:210:4: TOK_VOID
        	    {
        	         MATCHT(TOK_VOID, &FOLLOW_TOK_VOID_in_method_type_spec708); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethod_type_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			ctx->parser->onTypeDeclaration( "void", false );
        	            		
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:214:4: type_declaration
        	    {
        	        FOLLOWPUSH(FOLLOW_type_declaration_in_method_type_spec717);
        	        type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemethod_type_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemethod_type_specEx; /* Prevent compiler warnings */
    rulemethod_type_specEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end method_type_spec */

/** 
 * $ANTLR start type_declaration
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:217:1: type_declaration : ( BASIC_TYPE | qualified_identifier ) ( pair_of_braces )? ;
 */
static void
type_declaration(pCSLParser ctx)
{   
     bool isArray; const char* qualifiedName; 
    pANTLR3_COMMON_TOKEN    BASIC_TYPE27;
    CSLParser_qualified_identifier_return qualified_identifier28;
    #undef	RETURN_TYPE_qualified_identifier28
    #define	RETURN_TYPE_qualified_identifier28 CSLParser_qualified_identifier_return

    /* Initialize rule variables
     */


     isArray = false; qualifiedName = NULL; 
    BASIC_TYPE27       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:220:2: ( ( BASIC_TYPE | qualified_identifier ) ( pair_of_braces )? )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:221:3: ( BASIC_TYPE | qualified_identifier ) ( pair_of_braces )?
        {

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:221:3: ( BASIC_TYPE | qualified_identifier )
            {
                int alt25=2;
                switch ( LA(1) ) 
                {
                case BASIC_TYPE:
                	{
                		alt25=1;
                	}
                    break;
                case ID:
                	{
                		alt25=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 25;
                    EXCEPTION->state        = 0;


                    goto ruletype_declarationEx;
                }

                switch (alt25) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:222:4: BASIC_TYPE
            	    {
            	        BASIC_TYPE27 = (pANTLR3_COMMON_TOKEN) MATCHT(BASIC_TYPE, &FOLLOW_BASIC_TYPE_in_type_declaration747); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletype_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	             qualifiedName = (const char*)(BASIC_TYPE27->getText(BASIC_TYPE27))->chars; 
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:223:6: qualified_identifier
            	    {
            	        FOLLOWPUSH(FOLLOW_qualified_identifier_in_type_declaration756);
            	        qualified_identifier28=qualified_identifier(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletype_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	             qualifiedName = (const char*)(STRSTREAM->toStringTT(STRSTREAM, qualified_identifier28.start, qualified_identifier28.stop))->chars; 
            	        }

            	    }
            	    break;

                }
            }

            // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:225:3: ( pair_of_braces )?
            {
                int alt26=2;
                switch ( LA(1) ) 
                {
                    case OPEN_BRACE:
                    	{
                    		alt26=1;
                    	}
                        break;
                }

                switch (alt26) 
                {
            	case 1:
            	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:225:5: pair_of_braces
            	    {
            	        FOLLOWPUSH(FOLLOW_pair_of_braces_in_type_declaration768);
            	        pair_of_braces(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletype_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	             isArray = true; 
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {

                  			ctx->parser->onTypeDeclaration( qualifiedName, isArray );
                  		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletype_declarationEx; /* Prevent compiler warnings */
    ruletype_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end type_declaration */

/** 
 * $ANTLR start pair_of_braces
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:231:1: pair_of_braces : OPEN_BRACE CLOSE_BRACE ;
 */
static void
pair_of_braces(pCSLParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:232:2: ( OPEN_BRACE CLOSE_BRACE )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:232:4: OPEN_BRACE CLOSE_BRACE
        {
             MATCHT(OPEN_BRACE, &FOLLOW_OPEN_BRACE_in_pair_of_braces793); 
            if  (HASEXCEPTION())
            {
                goto rulepair_of_bracesEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(CLOSE_BRACE, &FOLLOW_CLOSE_BRACE_in_pair_of_braces795); 
            if  (HASEXCEPTION())
            {
                goto rulepair_of_bracesEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepair_of_bracesEx; /* Prevent compiler warnings */
    rulepair_of_bracesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end pair_of_braces */

/** 
 * $ANTLR start param_io
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:235:1: param_io returns [ bool isIn, bool isOut ] : ( TOK_IN | TOK_OUT | TOK_INOUT );
 */
static CSLParser_param_io_return
param_io(pCSLParser ctx)
{   
    CSLParser_param_io_return retval;

    /* Initialize rule variables
     */


     retval.isIn= false; retval.isOut= false; 
    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:237:2: ( TOK_IN | TOK_OUT | TOK_INOUT )
            
            ANTLR3_UINT32 alt27;

            alt27=3;

            switch ( LA(1) ) 
            {
            case TOK_IN:
            	{
            		alt27=1;
            	}
                break;
            case TOK_OUT:
            	{
            		alt27=2;
            	}
                break;
            case TOK_INOUT:
            	{
            		alt27=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruleparam_ioEx;
            }

            switch (alt27) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:237:4: TOK_IN
        	    {
        	         MATCHT(TOK_IN, &FOLLOW_TOK_IN_in_param_io816); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparam_ioEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             retval.isIn= true; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:238:4: TOK_OUT
        	    {
        	         MATCHT(TOK_OUT, &FOLLOW_TOK_OUT_in_param_io822); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparam_ioEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             retval.isOut= true; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:239:4: TOK_INOUT
        	    {
        	         MATCHT(TOK_INOUT, &FOLLOW_TOK_INOUT_in_param_io828); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparam_ioEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             retval.isIn= true; retval.isOut= true; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleparam_ioEx; /* Prevent compiler warnings */
    ruleparam_ioEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end param_io */

/** 
 * $ANTLR start interface_role
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:242:1: interface_role returns [ bool isFacet ] : ( PROVIDES | RECEIVES );
 */
static bool
interface_role(pCSLParser ctx)
{   
    bool isFacet;

    /* Initialize rule variables
     */


    {
        {
            //  /Users/tbastos/Projects/coral/src/core/csl/CSL.g:243:2: ( PROVIDES | RECEIVES )
            
            ANTLR3_UINT32 alt28;

            alt28=2;

            switch ( LA(1) ) 
            {
            case PROVIDES:
            	{
            		alt28=1;
            	}
                break;
            case RECEIVES:
            	{
            		alt28=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return isFacet;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto ruleinterface_roleEx;
            }

            switch (alt28) 
            {
        	case 1:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:243:4: PROVIDES
        	    {
        	         MATCHT(PROVIDES, &FOLLOW_PROVIDES_in_interface_role844); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinterface_roleEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return isFacet;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             isFacet= true; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:244:4: RECEIVES
        	    {
        	         MATCHT(RECEIVES, &FOLLOW_RECEIVES_in_interface_role851); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinterface_roleEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return isFacet;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             isFacet= false; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleinterface_roleEx; /* Prevent compiler warnings */
    ruleinterface_roleEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return isFacet;
}
/* $ANTLR end interface_role */

/** 
 * $ANTLR start comment
 * /Users/tbastos/Projects/coral/src/core/csl/CSL.g:247:1: comment : COMMENT ;
 */
static void
comment(pCSLParser ctx)
{   
    pANTLR3_COMMON_TOKEN    COMMENT29;

    /* Initialize rule variables
     */


    COMMENT29       = NULL;

    {
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:248:2: ( COMMENT )
        // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:248:4: COMMENT
        {
            COMMENT29 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMENT, &FOLLOW_COMMENT_in_comment864); 
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 ctx->parser->onComment( (const char*)(COMMENT29->getText(COMMENT29))->chars ); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommentEx; /* Prevent compiler warnings */
    rulecommentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end comment */

// $ANTLR start synpred1_CSL
static void synpred1_CSL_fragment(pCSLParser ctx ) 
{
    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:153:4: ( method_type_spec ID OPEN_PAREN )
    // /Users/tbastos/Projects/coral/src/core/csl/CSL.g:153:6: method_type_spec ID OPEN_PAREN
    {
        FOLLOWPUSH(FOLLOW_method_type_spec_in_synpred1_CSL498);
        method_type_spec(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_CSLEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(ID, &FOLLOW_ID_in_synpred1_CSL500); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_CSLEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(OPEN_PAREN, &FOLLOW_OPEN_PAREN_in_synpred1_CSL502); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_CSLEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_CSLEx; /* Prevent compiler warnings */
rulesynpred1_CSLEx: ;

}
// $ANTLR end synpred1_CSL
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_CSL(pCSLParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_CSL_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
